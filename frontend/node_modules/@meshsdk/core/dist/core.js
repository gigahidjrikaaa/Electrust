import { customAlphabet as Ce } from "nanoid";
import * as a from "@emurgo/cardano-serialization-lib-nodejs";
import L from "axios";
import { mnemonicToEntropy as we, generateMnemonic as ze } from "bip39";
import { COSEKey as Be, COSESign1 as We, Label as X, Int as wt, BigNum as Nt, KeyType as Je, AlgorithmId as Se, CBORValue as Mt, HeaderMap as Xt, Headers as je, ProtectedHeaderMap as Xe, COSESign1Builder as Ze } from "@emurgo/cardano-message-signing-nodejs";
const ts = ["testnet", "preview", "preprod", "mainnet"], es = (r) => ts.includes(r), at = {
  mem: 7e6,
  steps: 3e9
}, v = {
  epoch: 0,
  coinsPerUTxOSize: "4310",
  priceMem: 0.0577,
  priceStep: 721e-7,
  minFeeA: 44,
  minFeeB: 155381,
  keyDeposit: "2000000",
  maxTxSize: 16384,
  maxValSize: "5000",
  poolDeposit: "500000000",
  maxCollateralInputs: 3,
  decentralisation: 0,
  maxBlockSize: 98304,
  collateralPercent: 150,
  maxBlockHeaderSize: 1100,
  minPoolCost: "340000000",
  maxTxExMem: "16000000",
  maxTxExSteps: "10000000000",
  maxBlockExMem: "80000000",
  maxBlockExSteps: "40000000000"
}, Pt = 2147483648, R = {
  V1: a.Language.new_plutus_v1(),
  V2: a.Language.new_plutus_v2()
}, F = 56, ss = {
  CERT: a.RedeemerTag.new_cert(),
  MINT: a.RedeemerTag.new_mint(),
  REWARD: a.RedeemerTag.new_reward(),
  SPEND: a.RedeemerTag.new_spend()
}, Qt = {
  testnet: ["74", "1598400", "1595967616", "432000"],
  preview: ["183", "15811222", "1682467200", "86400"],
  preprod: ["65", "26438400", "1682121600", "432000"],
  mainnet: ["208", "4492800", "1596059091", "432000"]
}, Zt = {
  ALONZO: a.TxBuilderConstants.plutus_alonzo_cost_models(),
  BABBAGE: (() => {
    const r = a.Costmdls.new(), e = a.CostModel.new();
    Object.values({
      "addInteger-cpu-arguments-intercept": 205665,
      "addInteger-cpu-arguments-slope": 812,
      "addInteger-memory-arguments-intercept": 1,
      "addInteger-memory-arguments-slope": 1,
      "appendByteString-cpu-arguments-intercept": 1e3,
      "appendByteString-cpu-arguments-slope": 571,
      "appendByteString-memory-arguments-intercept": 0,
      "appendByteString-memory-arguments-slope": 1,
      "appendString-cpu-arguments-intercept": 1e3,
      "appendString-cpu-arguments-slope": 24177,
      "appendString-memory-arguments-intercept": 4,
      "appendString-memory-arguments-slope": 1,
      "bData-cpu-arguments": 1e3,
      "bData-memory-arguments": 32,
      "blake2b_256-cpu-arguments-intercept": 117366,
      "blake2b_256-cpu-arguments-slope": 10475,
      "blake2b_256-memory-arguments": 4,
      "cekApplyCost-exBudgetCPU": 23e3,
      "cekApplyCost-exBudgetMemory": 100,
      "cekBuiltinCost-exBudgetCPU": 23e3,
      "cekBuiltinCost-exBudgetMemory": 100,
      "cekConstCost-exBudgetCPU": 23e3,
      "cekConstCost-exBudgetMemory": 100,
      "cekDelayCost-exBudgetCPU": 23e3,
      "cekDelayCost-exBudgetMemory": 100,
      "cekForceCost-exBudgetCPU": 23e3,
      "cekForceCost-exBudgetMemory": 100,
      "cekLamCost-exBudgetCPU": 23e3,
      "cekLamCost-exBudgetMemory": 100,
      "cekStartupCost-exBudgetCPU": 100,
      "cekStartupCost-exBudgetMemory": 100,
      "cekVarCost-exBudgetCPU": 23e3,
      "cekVarCost-exBudgetMemory": 100,
      "chooseData-cpu-arguments": 19537,
      "chooseData-memory-arguments": 32,
      "chooseList-cpu-arguments": 175354,
      "chooseList-memory-arguments": 32,
      "chooseUnit-cpu-arguments": 46417,
      "chooseUnit-memory-arguments": 4,
      "consByteString-cpu-arguments-intercept": 221973,
      "consByteString-cpu-arguments-slope": 511,
      "consByteString-memory-arguments-intercept": 0,
      "consByteString-memory-arguments-slope": 1,
      "constrData-cpu-arguments": 89141,
      "constrData-memory-arguments": 32,
      "decodeUtf8-cpu-arguments-intercept": 497525,
      "decodeUtf8-cpu-arguments-slope": 14068,
      "decodeUtf8-memory-arguments-intercept": 4,
      "decodeUtf8-memory-arguments-slope": 2,
      "divideInteger-cpu-arguments-constant": 196500,
      "divideInteger-cpu-arguments-model-arguments-intercept": 453240,
      "divideInteger-cpu-arguments-model-arguments-slope": 220,
      "divideInteger-memory-arguments-intercept": 0,
      "divideInteger-memory-arguments-minimum": 1,
      "divideInteger-memory-arguments-slope": 1,
      "encodeUtf8-cpu-arguments-intercept": 1e3,
      "encodeUtf8-cpu-arguments-slope": 28662,
      "encodeUtf8-memory-arguments-intercept": 4,
      "encodeUtf8-memory-arguments-slope": 2,
      "equalsByteString-cpu-arguments-constant": 245e3,
      "equalsByteString-cpu-arguments-intercept": 216773,
      "equalsByteString-cpu-arguments-slope": 62,
      "equalsByteString-memory-arguments": 1,
      "equalsData-cpu-arguments-intercept": 1060367,
      "equalsData-cpu-arguments-slope": 12586,
      "equalsData-memory-arguments": 1,
      "equalsInteger-cpu-arguments-intercept": 208512,
      "equalsInteger-cpu-arguments-slope": 421,
      "equalsInteger-memory-arguments": 1,
      "equalsString-cpu-arguments-constant": 187e3,
      "equalsString-cpu-arguments-intercept": 1e3,
      "equalsString-cpu-arguments-slope": 52998,
      "equalsString-memory-arguments": 1,
      "fstPair-cpu-arguments": 80436,
      "fstPair-memory-arguments": 32,
      "headList-cpu-arguments": 43249,
      "headList-memory-arguments": 32,
      "iData-cpu-arguments": 1e3,
      "iData-memory-arguments": 32,
      "ifThenElse-cpu-arguments": 80556,
      "ifThenElse-memory-arguments": 1,
      "indexByteString-cpu-arguments": 57667,
      "indexByteString-memory-arguments": 4,
      "lengthOfByteString-cpu-arguments": 1e3,
      "lengthOfByteString-memory-arguments": 10,
      "lessThanByteString-cpu-arguments-intercept": 197145,
      "lessThanByteString-cpu-arguments-slope": 156,
      "lessThanByteString-memory-arguments": 1,
      "lessThanEqualsByteString-cpu-arguments-intercept": 197145,
      "lessThanEqualsByteString-cpu-arguments-slope": 156,
      "lessThanEqualsByteString-memory-arguments": 1,
      "lessThanEqualsInteger-cpu-arguments-intercept": 204924,
      "lessThanEqualsInteger-cpu-arguments-slope": 473,
      "lessThanEqualsInteger-memory-arguments": 1,
      "lessThanInteger-cpu-arguments-intercept": 208896,
      "lessThanInteger-cpu-arguments-slope": 511,
      "lessThanInteger-memory-arguments": 1,
      "listData-cpu-arguments": 52467,
      "listData-memory-arguments": 32,
      "mapData-cpu-arguments": 64832,
      "mapData-memory-arguments": 32,
      "mkCons-cpu-arguments": 65493,
      "mkCons-memory-arguments": 32,
      "mkNilData-cpu-arguments": 22558,
      "mkNilData-memory-arguments": 32,
      "mkNilPairData-cpu-arguments": 16563,
      "mkNilPairData-memory-arguments": 32,
      "mkPairData-cpu-arguments": 76511,
      "mkPairData-memory-arguments": 32,
      "modInteger-cpu-arguments-constant": 196500,
      "modInteger-cpu-arguments-model-arguments-intercept": 453240,
      "modInteger-cpu-arguments-model-arguments-slope": 220,
      "modInteger-memory-arguments-intercept": 0,
      "modInteger-memory-arguments-minimum": 1,
      "modInteger-memory-arguments-slope": 1,
      "multiplyInteger-cpu-arguments-intercept": 69522,
      "multiplyInteger-cpu-arguments-slope": 11687,
      "multiplyInteger-memory-arguments-intercept": 0,
      "multiplyInteger-memory-arguments-slope": 1,
      "nullList-cpu-arguments": 60091,
      "nullList-memory-arguments": 32,
      "quotientInteger-cpu-arguments-constant": 196500,
      "quotientInteger-cpu-arguments-model-arguments-intercept": 453240,
      "quotientInteger-cpu-arguments-model-arguments-slope": 220,
      "quotientInteger-memory-arguments-intercept": 0,
      "quotientInteger-memory-arguments-minimum": 1,
      "quotientInteger-memory-arguments-slope": 1,
      "remainderInteger-cpu-arguments-constant": 196500,
      "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
      "remainderInteger-cpu-arguments-model-arguments-slope": 220,
      "remainderInteger-memory-arguments-intercept": 0,
      "remainderInteger-memory-arguments-minimum": 1,
      "remainderInteger-memory-arguments-slope": 1,
      "sha2_256-cpu-arguments-intercept": 806990,
      "sha2_256-cpu-arguments-slope": 30482,
      "sha2_256-memory-arguments": 4,
      "sha3_256-cpu-arguments-intercept": 1927926,
      "sha3_256-cpu-arguments-slope": 82523,
      "sha3_256-memory-arguments": 4,
      "sliceByteString-cpu-arguments-intercept": 265318,
      "sliceByteString-cpu-arguments-slope": 0,
      "sliceByteString-memory-arguments-intercept": 4,
      "sliceByteString-memory-arguments-slope": 0,
      "sndPair-cpu-arguments": 85931,
      "sndPair-memory-arguments": 32,
      "subtractInteger-cpu-arguments-intercept": 205665,
      "subtractInteger-cpu-arguments-slope": 812,
      "subtractInteger-memory-arguments-intercept": 1,
      "subtractInteger-memory-arguments-slope": 1,
      "tailList-cpu-arguments": 41182,
      "tailList-memory-arguments": 32,
      "trace-cpu-arguments": 212342,
      "trace-memory-arguments": 32,
      "unBData-cpu-arguments": 31220,
      "unBData-memory-arguments": 32,
      "unConstrData-cpu-arguments": 32696,
      "unConstrData-memory-arguments": 32,
      "unIData-cpu-arguments": 43357,
      "unIData-memory-arguments": 32,
      "unListData-cpu-arguments": 32247,
      "unListData-memory-arguments": 32,
      "unMapData-cpu-arguments": 38314,
      "unMapData-memory-arguments": 32,
      "verifyEd25519Signature-cpu-arguments-intercept": 57996947,
      "verifyEd25519Signature-cpu-arguments-slope": 18975,
      "verifyEd25519Signature-memory-arguments": 10
    }).forEach((s, n) => e.set(n, a.Int.new_i32(s)));
    const t = a.CostModel.new();
    return Object.values({
      "addInteger-cpu-arguments-intercept": 205665,
      "addInteger-cpu-arguments-slope": 812,
      "addInteger-memory-arguments-intercept": 1,
      "addInteger-memory-arguments-slope": 1,
      "appendByteString-cpu-arguments-intercept": 1e3,
      "appendByteString-cpu-arguments-slope": 571,
      "appendByteString-memory-arguments-intercept": 0,
      "appendByteString-memory-arguments-slope": 1,
      "appendString-cpu-arguments-intercept": 1e3,
      "appendString-cpu-arguments-slope": 24177,
      "appendString-memory-arguments-intercept": 4,
      "appendString-memory-arguments-slope": 1,
      "bData-cpu-arguments": 1e3,
      "bData-memory-arguments": 32,
      "blake2b_256-cpu-arguments-intercept": 117366,
      "blake2b_256-cpu-arguments-slope": 10475,
      "blake2b_256-memory-arguments": 4,
      "cekApplyCost-exBudgetCPU": 23e3,
      "cekApplyCost-exBudgetMemory": 100,
      "cekBuiltinCost-exBudgetCPU": 23e3,
      "cekBuiltinCost-exBudgetMemory": 100,
      "cekConstCost-exBudgetCPU": 23e3,
      "cekConstCost-exBudgetMemory": 100,
      "cekDelayCost-exBudgetCPU": 23e3,
      "cekDelayCost-exBudgetMemory": 100,
      "cekForceCost-exBudgetCPU": 23e3,
      "cekForceCost-exBudgetMemory": 100,
      "cekLamCost-exBudgetCPU": 23e3,
      "cekLamCost-exBudgetMemory": 100,
      "cekStartupCost-exBudgetCPU": 100,
      "cekStartupCost-exBudgetMemory": 100,
      "cekVarCost-exBudgetCPU": 23e3,
      "cekVarCost-exBudgetMemory": 100,
      "chooseData-cpu-arguments": 19537,
      "chooseData-memory-arguments": 32,
      "chooseList-cpu-arguments": 175354,
      "chooseList-memory-arguments": 32,
      "chooseUnit-cpu-arguments": 46417,
      "chooseUnit-memory-arguments": 4,
      "consByteString-cpu-arguments-intercept": 221973,
      "consByteString-cpu-arguments-slope": 511,
      "consByteString-memory-arguments-intercept": 0,
      "consByteString-memory-arguments-slope": 1,
      "constrData-cpu-arguments": 89141,
      "constrData-memory-arguments": 32,
      "decodeUtf8-cpu-arguments-intercept": 497525,
      "decodeUtf8-cpu-arguments-slope": 14068,
      "decodeUtf8-memory-arguments-intercept": 4,
      "decodeUtf8-memory-arguments-slope": 2,
      "divideInteger-cpu-arguments-constant": 196500,
      "divideInteger-cpu-arguments-model-arguments-intercept": 453240,
      "divideInteger-cpu-arguments-model-arguments-slope": 220,
      "divideInteger-memory-arguments-intercept": 0,
      "divideInteger-memory-arguments-minimum": 1,
      "divideInteger-memory-arguments-slope": 1,
      "encodeUtf8-cpu-arguments-intercept": 1e3,
      "encodeUtf8-cpu-arguments-slope": 28662,
      "encodeUtf8-memory-arguments-intercept": 4,
      "encodeUtf8-memory-arguments-slope": 2,
      "equalsByteString-cpu-arguments-constant": 245e3,
      "equalsByteString-cpu-arguments-intercept": 216773,
      "equalsByteString-cpu-arguments-slope": 62,
      "equalsByteString-memory-arguments": 1,
      "equalsData-cpu-arguments-intercept": 1060367,
      "equalsData-cpu-arguments-slope": 12586,
      "equalsData-memory-arguments": 1,
      "equalsInteger-cpu-arguments-intercept": 208512,
      "equalsInteger-cpu-arguments-slope": 421,
      "equalsInteger-memory-arguments": 1,
      "equalsString-cpu-arguments-constant": 187e3,
      "equalsString-cpu-arguments-intercept": 1e3,
      "equalsString-cpu-arguments-slope": 52998,
      "equalsString-memory-arguments": 1,
      "fstPair-cpu-arguments": 80436,
      "fstPair-memory-arguments": 32,
      "headList-cpu-arguments": 43249,
      "headList-memory-arguments": 32,
      "iData-cpu-arguments": 1e3,
      "iData-memory-arguments": 32,
      "ifThenElse-cpu-arguments": 80556,
      "ifThenElse-memory-arguments": 1,
      "indexByteString-cpu-arguments": 57667,
      "indexByteString-memory-arguments": 4,
      "lengthOfByteString-cpu-arguments": 1e3,
      "lengthOfByteString-memory-arguments": 10,
      "lessThanByteString-cpu-arguments-intercept": 197145,
      "lessThanByteString-cpu-arguments-slope": 156,
      "lessThanByteString-memory-arguments": 1,
      "lessThanEqualsByteString-cpu-arguments-intercept": 197145,
      "lessThanEqualsByteString-cpu-arguments-slope": 156,
      "lessThanEqualsByteString-memory-arguments": 1,
      "lessThanEqualsInteger-cpu-arguments-intercept": 204924,
      "lessThanEqualsInteger-cpu-arguments-slope": 473,
      "lessThanEqualsInteger-memory-arguments": 1,
      "lessThanInteger-cpu-arguments-intercept": 208896,
      "lessThanInteger-cpu-arguments-slope": 511,
      "lessThanInteger-memory-arguments": 1,
      "listData-cpu-arguments": 52467,
      "listData-memory-arguments": 32,
      "mapData-cpu-arguments": 64832,
      "mapData-memory-arguments": 32,
      "mkCons-cpu-arguments": 65493,
      "mkCons-memory-arguments": 32,
      "mkNilData-cpu-arguments": 22558,
      "mkNilData-memory-arguments": 32,
      "mkNilPairData-cpu-arguments": 16563,
      "mkNilPairData-memory-arguments": 32,
      "mkPairData-cpu-arguments": 76511,
      "mkPairData-memory-arguments": 32,
      "modInteger-cpu-arguments-constant": 196500,
      "modInteger-cpu-arguments-model-arguments-intercept": 453240,
      "modInteger-cpu-arguments-model-arguments-slope": 220,
      "modInteger-memory-arguments-intercept": 0,
      "modInteger-memory-arguments-minimum": 1,
      "modInteger-memory-arguments-slope": 1,
      "multiplyInteger-cpu-arguments-intercept": 69522,
      "multiplyInteger-cpu-arguments-slope": 11687,
      "multiplyInteger-memory-arguments-intercept": 0,
      "multiplyInteger-memory-arguments-slope": 1,
      "nullList-cpu-arguments": 60091,
      "nullList-memory-arguments": 32,
      "quotientInteger-cpu-arguments-constant": 196500,
      "quotientInteger-cpu-arguments-model-arguments-intercept": 453240,
      "quotientInteger-cpu-arguments-model-arguments-slope": 220,
      "quotientInteger-memory-arguments-intercept": 0,
      "quotientInteger-memory-arguments-minimum": 1,
      "quotientInteger-memory-arguments-slope": 1,
      "remainderInteger-cpu-arguments-constant": 196500,
      "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
      "remainderInteger-cpu-arguments-model-arguments-slope": 220,
      "remainderInteger-memory-arguments-intercept": 0,
      "remainderInteger-memory-arguments-minimum": 1,
      "remainderInteger-memory-arguments-slope": 1,
      "serialiseData-cpu-arguments-intercept": 1159724,
      "serialiseData-cpu-arguments-slope": 392670,
      "serialiseData-memory-arguments-intercept": 0,
      "serialiseData-memory-arguments-slope": 2,
      "sha2_256-cpu-arguments-intercept": 806990,
      "sha2_256-cpu-arguments-slope": 30482,
      "sha2_256-memory-arguments": 4,
      "sha3_256-cpu-arguments-intercept": 1927926,
      "sha3_256-cpu-arguments-slope": 82523,
      "sha3_256-memory-arguments": 4,
      "sliceByteString-cpu-arguments-intercept": 265318,
      "sliceByteString-cpu-arguments-slope": 0,
      "sliceByteString-memory-arguments-intercept": 4,
      "sliceByteString-memory-arguments-slope": 0,
      "sndPair-cpu-arguments": 85931,
      "sndPair-memory-arguments": 32,
      "subtractInteger-cpu-arguments-intercept": 205665,
      "subtractInteger-cpu-arguments-slope": 812,
      "subtractInteger-memory-arguments-intercept": 1,
      "subtractInteger-memory-arguments-slope": 1,
      "tailList-cpu-arguments": 41182,
      "tailList-memory-arguments": 32,
      "trace-cpu-arguments": 212342,
      "trace-memory-arguments": 32,
      "unBData-cpu-arguments": 31220,
      "unBData-memory-arguments": 32,
      "unConstrData-cpu-arguments": 32696,
      "unConstrData-memory-arguments": 32,
      "unIData-cpu-arguments": 43357,
      "unIData-memory-arguments": 32,
      "unListData-cpu-arguments": 32247,
      "unListData-memory-arguments": 32,
      "unMapData-cpu-arguments": 38314,
      "unMapData-memory-arguments": 32,
      "verifyEcdsaSecp256k1Signature-cpu-arguments": 35892428,
      "verifyEcdsaSecp256k1Signature-memory-arguments": 10,
      "verifyEd25519Signature-cpu-arguments-intercept": 57996947,
      "verifyEd25519Signature-cpu-arguments-slope": 18975,
      "verifyEd25519Signature-memory-arguments": 10,
      "verifySchnorrSecp256k1Signature-cpu-arguments-intercept": 38887044,
      "verifySchnorrSecp256k1Signature-cpu-arguments-slope": 32947,
      "verifySchnorrSecp256k1Signature-memory-arguments": 10
    }).forEach((s, n) => t.set(n, a.Int.new_i32(s))), r.insert(a.Language.new_plutus_v1(), e), r.insert(a.Language.new_plutus_v2(), t), r;
  })()
}, rs = {
  ALONZO: {
    V1: "a141005901d59f1a000302590001011a00060bc719026d00011a000249f01903e800011a000249f018201a0025cea81971f70419744d186419744d186419744d186419744d186419744d186419744d18641864186419744d18641a000249f018201a000249f018201a000249f018201a000249f01903e800011a000249f018201a000249f01903e800081a000242201a00067e2318760001011a000249f01903e800081a000249f01a0001b79818f7011a000249f0192710011a0002155e19052e011903e81a000249f01903e8011a000249f018201a000249f018201a000249f0182001011a000249f0011a000249f0041a000194af18f8011a000194af18f8011a0002377c190556011a0002bdea1901f1011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000242201a00067e23187600010119f04c192bd200011a000249f018201a000242201a00067e2318760001011a000242201a00067e2318760001011a0025cea81971f704001a000141bb041a000249f019138800011a000249f018201a000302590001011a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a000249f018201a00330da70101ff"
  },
  BABBAGE: {
    V1: "a141005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff",
    V2: "a20198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201b00000004a817c8001b00000004a817c8001a009063b91903fd0a1b00000004a817c800001b00000004a817c80041005901b69f1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a009063b91903fd0aff"
  }
}, Vt = {
  [a.NetworkInfo.testnet().network_id()]: "8d18d786e92776c824607fd8e193ec535c79dc61ea2405ddf3b09fe3",
  [a.NetworkInfo.mainnet().network_id()]: "f0ff48bbb7bbe9d59a40f1ce90e9e9d0ff5002ec48f232b49ca0fb9a"
}, ns = {
  mainnet: "wss://ogmios-api.mainnet.dandelion.link",
  preprod: "wss://ogmios-api.iohk-preprod.dandelion.link",
  preview: "__TBD_SOON_TM__",
  testnet: "wss://ogmios-api.testnet.dandelion.link"
}, as = {
  LQ: "da8c30857834c6ae7203935b89278c532b3995245295456f993e1d244c51",
  MIN: "29d222ce763455e3d7a09a665ce554f00ac89d2e99a1a83d267170c64d494e",
  NTX: "edfd7a1d77bcb8b884c474bdc92a16002d1fb720e454fa6e993444794e5458",
  iBTC: "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069425443",
  iETH: "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069455448",
  iUSD: "f66d78b4a3cb3d37afa0ec36461e51ecbde00f26c8f0a68f94b6988069555344",
  MILK: "8a1cfae21368b8bebbbed9800fec304e95cce39a2a57dc35e2e3ebaa4d494c4b",
  AGIX: "f43a62fdc3965df486de8a0d32fe800963589c41b38946602a0dc53541474958",
  MELD: "6ac8ef33b510ec004fe11585f7c5a9f0c07f0c23428ab4f29c1d7d104d454c44",
  INDY: "533bb94a8850ee3ccbe483106489399112b74c905342cb1792a797a0494e4459",
  CLAY: "38ad9dc3aec6a2f38e220142b9aa6ade63ebe71f65e7cc2b7d8a8535434c4159",
  MCOS: "6f46e1304b16d884c85c62fb0eef35028facdc41aaa0fd319a152ed64d434f53",
  DING: "ce5b9e0f8a88255b65f2e4d065c6e716e9fa9a8a86dfb86423dd1ac044494e47",
  GERO: "10a49b996e2402269af553a8a96fb8eb90d79e9eca79e2b4223057b64745524f",
  NMKR: "5dac8536653edc12f6f5e1045d8164b9f59998d3bdc300fc928434894e4d4b52",
  PAVIA: "884892bcdc360bcef87d6b3f806e7f9cd5ac30d999d49970e7a903ae5041564941",
  HOSKY: "a0028f350aaabe0545fdcb56b039bfb08e4bb4d8c4d7c3c7d481c235484f534b59",
  YUMMI: "078eafce5cd7edafdf63900edef2c1ea759e77f30ca81d6bbdeec92479756d6d69",
  C3: "8e51398904a5d3fc129fbf4f1589701de23c7824d5c90fdb9490e15a434841524c4933",
  GIMBAL: "2b0a04a7b60132b1805b296c7fcb3b217ff14413991bf76f72663c3067696d62616c",
  SUNDAE: "9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d7753554e444145",
  GREENS: "4623ab311b7d982d8d26fcbe1a9439ca56661aafcdcd8d8a0ef31fd6475245454e53",
  GENS: "dda5fdb1002f7389b33e036b6afee82a8189becb6cba852e8b79b4fb0014df1047454e53",
  SOCIETY: "25f0fc240e91bd95dcdaebd2ba7713fc5168ac77234a3d79449fc20c534f4349455459",
  DJED: "8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd61446a65644d6963726f555344",
  SHEN: "8db269c3ec630e06ae29f74bc39edd1f87c819f1056206e879a1cd615368656e4d6963726f555344",
  WMT: "1d7f33bd23d85e1a25d87d86fac4f199c3197a2f7afeb662a0f34e1e776f726c646d6f62696c65746f6b656e",
  COPI: "b6a7467ea1deb012808ef4e87b5ff371e85f7142d7b356a40d9b42a0436f726e75636f70696173205b76696120436861696e506f72742e696f5d"
}, te = [
  "begin",
  "eternl",
  "flint",
  "lace",
  "nami",
  "nufi",
  "gerowallet",
  "typhoncip30",
  "vespr",
  "yoroi"
], is = (r, e, t = "5000000") => {
  const s = a.BigNum.from_str(r.get("lovelace") ?? "0").checked_add(a.BigNum.from_str(t)), n = e.filter((c) => c.output.amount.filter((u) => u.unit !== "lovelace").some((u) => r.has(u.unit))), i = ds(n);
  return [
    ...i.less_than(s) ? hs(s.clamped_sub(i).to_str(), e.filter((c) => !n.some((u) => u.input.txHash === c.input.txHash && u.input.outputIndex === c.input.outputIndex))) : [],
    ...n
  ];
}, or = (r, e, t = !1, { maxTxSize: s, minFeeA: n, minFeeB: i } = v) => {
  const o = e.filter((l) => Ee(l) === !1).sort(Rt), c = a.BigNum.from_str(Le(s, n, i)), u = t ? a.BigNum.from_str(r).checked_add(c).to_str() : r;
  return It(o, /* @__PURE__ */ new Map([
    ["lovelace", u]
  ]));
}, os = (r, e, t = !1, s = v) => {
  const n = e.filter(Ee).sort(Rt), i = us(s), o = r.get("lovelace") ?? "0", c = t ? a.BigNum.from_str(o).checked_add(i).to_str() : o;
  return r.set("lovelace", c), It(n, r);
}, cs = (r, e) => Array.from(e, (t) => ({ unit: t[0], quantity: a.BigNum.from_str(t[1]) })).every((t) => r.filter((s) => s.output.amount.find((n) => n.unit === t.unit) !== void 0).reduce((s, n) => {
  const i = n.output.amount.reduce((o, c) => o.checked_add(a.BigNum.from_str(t.unit === c.unit ? c.quantity : "0")), a.BigNum.from_str("0"));
  return s.checked_add(i);
}, a.BigNum.from_str("0")).less_than(t.quantity) === !1), Rt = (r, e) => {
  var n, i;
  const t = a.BigNum.from_str(((n = r.output.amount.find((o) => o.unit === "lovelace")) == null ? void 0 : n.quantity) ?? "0");
  return a.BigNum.from_str(((i = e.output.amount.find((o) => o.unit === "lovelace")) == null ? void 0 : i.quantity) ?? "0").compare(t);
}, us = (r) => {
  const { maxTxSize: e, minFeeA: t, minFeeB: s } = r;
  return a.BigNum.from_str(Le(e, t, s));
}, Ee = (r) => r.output.amount.length > 1, ds = (r) => r.reduce((e, t) => {
  var n;
  const s = ((n = t.output.amount.find((i) => i.unit === "lovelace")) == null ? void 0 : n.quantity) ?? "0";
  return e.checked_add(a.BigNum.from_str(s));
}, a.BigNum.from_str("0")), hs = (r, e) => {
  const t = e.sort(Rt);
  return It(t, /* @__PURE__ */ new Map([
    ["lovelace", r]
  ]));
}, It = (r, e, t = []) => r.length === 0 || cs(t, e) ? t : ls(r[0], e) ? It(r.slice(1), e, [...t, r[0]]) : It(r.slice(1), e, t), ls = (r, e) => Array.from(e.keys()).some((t) => r.output.amount.find((s) => s.unit === t) !== void 0), As = (r, e) => {
  const t = ms(e), s = Is(r, e);
  return {
    coseKey: b(t.to_bytes()),
    coseSign1: b(s.to_bytes())
  };
}, cr = (r, e, { key: t, signature: s }) => {
  var o, c;
  const n = Be.from_bytes(p(t)), i = We.from_bytes(p(s));
  if ((r == null ? void 0 : r.length) > 0) {
    const u = b(i.payload() ?? new Uint8Array());
    if (E(r) !== u)
      return !1;
  }
  if ((e == null ? void 0 : e.length) > 0) {
    const d = (o = i.headers().protected().deserialized_headers().header(X.new_text("address"))) == null ? void 0 : o.as_bytes();
    if (d === void 0)
      throw new Error("Couldn't find a signer address in signature");
    const A = (c = n.header(X.new_int(wt.new_negative(Nt.from_str("2"))))) == null ? void 0 : c.as_bytes();
    if (A === void 0)
      throw new Error("Couldn't find a signer key in signature");
    const l = nt(b(d)), g = Rs(b(A));
    if (gs(e, l, g) === !1)
      throw new Error("Couldn't check signature because of address mismatch");
    const I = Vs(b(i.signature())), y = i.signed_data().to_bytes();
    return g.verify(y, I);
  }
  return !1;
}, gs = (r, e, t) => {
  if (r !== e.to_bech32())
    return !1;
  try {
    return gt(r) === t.hash().to_hex();
  } catch {
    return !1;
  }
}, ms = (r) => {
  const e = Be.new(X.from_key_type(Je.OKP));
  return e.set_algorithm_id(X.from_algorithm_id(Se.EdDSA)), e.set_header(X.new_int(wt.new_negative(Nt.from_str("1"))), Mt.new_int(wt.new_i32(6))), e.set_header(X.new_int(wt.new_negative(Nt.from_str("2"))), Mt.new_bytes(r.key.to_public().as_bytes())), e;
}, Is = (r, e) => {
  const t = Xt.new(), s = Xt.new();
  t.set_algorithm_id(X.from_algorithm_id(Se.EdDSA)), t.set_header(X.new_text("address"), Mt.new_bytes(e.address.to_bytes()));
  const n = je.new(Xe.new(t), s), i = Ze.new(n, p(r.payload), !1);
  r.externalAAD !== void 0 && i.set_external_aad(p(r.externalAAD));
  const o = i.make_data_to_sign(), c = e.key.sign(o.to_bytes());
  return i.build(c.to_bytes());
};
var ee = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Qe = {}, Q = { exports: {} };
G.notEqual = fs;
G.notOk = _s;
G.equal = ps;
G.ok = G;
var be = G;
function ps(r, e, t) {
  G(r == e, t);
}
function fs(r, e, t) {
  G(r != e, t);
}
function _s(r, e) {
  G(!r, e);
}
function G(r, e) {
  if (!r)
    throw new Error(e || "AssertionError");
}
var O = { exports: {} };
function ys(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var xs = qt;
qt.supported = typeof WebAssembly < "u";
function qt(r) {
  if (!qt.supported)
    return null;
  var e = r && r.imports, t = Cs("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0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"), s = null, n = {
    buffer: t,
    memory: null,
    exports: null,
    realloc: i,
    onload: o
  };
  return o(function() {
  }), n;
  function i(u) {
    n.exports.memory.grow(Math.ceil(Math.abs(u - n.memory.length) / 65536)), n.memory = new Uint8Array(n.exports.memory.buffer);
  }
  function o(u) {
    if (n.exports)
      return u();
    if (s) {
      s.then(u.bind(null, null)).catch(u);
      return;
    }
    try {
      if (r && r.async)
        throw new Error("async");
      c({ instance: new WebAssembly.Instance(new WebAssembly.Module(t), e) });
    } catch {
      s = WebAssembly.instantiate(t, e).then(c);
    }
    o(u);
  }
  function c(u) {
    n.exports = u.instance.exports, n.memory = n.exports.memory && n.exports.memory.buffer && new Uint8Array(n.exports.memory.buffer);
  }
}
function Cs(r) {
  return typeof atob == "function" ? new Uint8Array(atob(r).split("").map(ws)) : new (ys("buffer")).Buffer(r, "base64");
}
function ws(r) {
  return r.charCodeAt(0);
}
var N = be, _ = xs(), q = 64, Bt = [];
O.exports = D;
var se = O.exports.BYTES_MIN = 16, re = O.exports.BYTES_MAX = 64;
O.exports.BYTES = 32;
var ne = O.exports.KEYBYTES_MIN = 16, ae = O.exports.KEYBYTES_MAX = 64;
O.exports.KEYBYTES = 32;
var ie = O.exports.SALTBYTES = 16, oe = O.exports.PERSONALBYTES = 16;
function D(r, e, t, s, n) {
  if (!(this instanceof D))
    return new D(r, e, t, s, n);
  if (!(_ && _.exports))
    throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
  r || (r = 32), n !== !0 && (N(r >= se, "digestLength must be at least " + se + ", was given " + r), N(r <= re, "digestLength must be at most " + re + ", was given " + r), e != null && N(e.length >= ne, "key must be at least " + ne + ", was given " + e.length), e != null && N(e.length <= ae, "key must be at least " + ae + ", was given " + e.length), t != null && N(t.length === ie, "salt must be exactly " + ie + ", was given " + t.length), s != null && N(s.length === oe, "personal must be exactly " + oe + ", was given " + s.length)), Bt.length || (Bt.push(q), q += 216), this.digestLength = r, this.finalized = !1, this.pointer = Bt.pop(), _.memory.fill(0, 0, 64), _.memory[0] = this.digestLength, _.memory[1] = e ? e.length : 0, _.memory[2] = 1, _.memory[3] = 1, t && _.memory.set(t, 32), s && _.memory.set(s, 48), this.pointer + 216 > _.memory.length && _.realloc(this.pointer + 216), _.exports.blake2b_init(this.pointer, this.digestLength), e && (this.update(e), _.memory.fill(0, q, q + e.length), _.memory[this.pointer + 200] = 128);
}
D.prototype.update = function(r) {
  return N(this.finalized === !1, "Hash instance finalized"), N(r, "input must be TypedArray or Buffer"), q + r.length > _.memory.length && _.realloc(q + r.length), _.memory.set(r, q), _.exports.blake2b_update(this.pointer, q, q + r.length), this;
};
D.prototype.digest = function(r) {
  if (N(this.finalized === !1, "Hash instance finalized"), this.finalized = !0, Bt.push(this.pointer), _.exports.blake2b_final(this.pointer), !r || r === "binary")
    return _.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  if (r === "hex")
    return Ss(_.memory, this.pointer + 128, this.digestLength);
  N(r.length >= this.digestLength, "input must be TypedArray or Buffer");
  for (var e = 0; e < this.digestLength; e++)
    r[e] = _.memory[this.pointer + 128 + e];
  return r;
};
D.prototype.final = D.prototype.digest;
D.WASM = _ && _.buffer;
D.SUPPORTED = typeof WebAssembly < "u";
D.ready = function(r) {
  if (r || (r = Bs), !_)
    return r(new Error("WebAssembly not supported"));
  var e = new Promise(function(t, s) {
    _.onload(function(n) {
      n ? s() : t(), r(n);
    });
  });
  return e;
};
D.prototype.ready = D.ready;
function Bs() {
}
function Ss(r, e, t) {
  for (var s = "", n = 0; n < t; n++)
    s += Es(r[e + n]);
  return s;
}
function Es(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}
var j = be, pt = O.exports;
function _t(r, e, t) {
  var s = r[e] + r[t], n = r[e + 1] + r[t + 1];
  s >= 4294967296 && n++, r[e] = s, r[e + 1] = n;
}
function ce(r, e, t, s) {
  var n = r[e] + t;
  t < 0 && (n += 4294967296);
  var i = r[e + 1] + s;
  n >= 4294967296 && i++, r[e] = n, r[e + 1] = i;
}
function ve(r, e) {
  return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function W(r, e, t, s, n, i) {
  var o = At[n], c = At[n + 1], u = At[i], d = At[i + 1];
  _t(m, r, e), ce(m, r, o, c);
  var A = m[s] ^ m[r], l = m[s + 1] ^ m[r + 1];
  m[s] = l, m[s + 1] = A, _t(m, t, s), A = m[e] ^ m[t], l = m[e + 1] ^ m[t + 1], m[e] = A >>> 24 ^ l << 8, m[e + 1] = l >>> 24 ^ A << 8, _t(m, r, e), ce(m, r, u, d), A = m[s] ^ m[r], l = m[s + 1] ^ m[r + 1], m[s] = A >>> 16 ^ l << 16, m[s + 1] = l >>> 16 ^ A << 16, _t(m, t, s), A = m[e] ^ m[t], l = m[e + 1] ^ m[t + 1], m[e] = l >>> 31 ^ A << 1, m[e + 1] = A >>> 31 ^ l << 1;
}
var De = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), Qs = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
], B = new Uint8Array(Qs.map(function(r) {
  return r * 2;
})), m = new Uint32Array(32), At = new Uint32Array(32);
function ke(r, e) {
  var t = 0;
  for (t = 0; t < 16; t++)
    m[t] = r.h[t], m[t + 16] = De[t];
  for (m[24] = m[24] ^ r.t, m[25] = m[25] ^ r.t / 4294967296, e && (m[28] = ~m[28], m[29] = ~m[29]), t = 0; t < 32; t++)
    At[t] = ve(r.b, 4 * t);
  for (t = 0; t < 12; t++)
    W(0, 8, 16, 24, B[t * 16 + 0], B[t * 16 + 1]), W(2, 10, 18, 26, B[t * 16 + 2], B[t * 16 + 3]), W(4, 12, 20, 28, B[t * 16 + 4], B[t * 16 + 5]), W(6, 14, 22, 30, B[t * 16 + 6], B[t * 16 + 7]), W(0, 10, 20, 30, B[t * 16 + 8], B[t * 16 + 9]), W(2, 12, 22, 24, B[t * 16 + 10], B[t * 16 + 11]), W(4, 14, 16, 26, B[t * 16 + 12], B[t * 16 + 13]), W(6, 8, 18, 28, B[t * 16 + 14], B[t * 16 + 15]);
  for (t = 0; t < 16; t++)
    r.h[t] = r.h[t] ^ m[t] ^ m[t + 16];
}
var J = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function ct(r, e, t, s) {
  J.fill(0), this.b = new Uint8Array(128), this.h = new Uint32Array(16), this.t = 0, this.c = 0, this.outlen = r, J[0] = r, e && (J[1] = e.length), J[2] = 1, J[3] = 1, t && J.set(t, 32), s && J.set(s, 48);
  for (var n = 0; n < 16; n++)
    this.h[n] = De[n] ^ ve(J, n * 4);
  e && (Te(this, e), this.c = 128);
}
ct.prototype.update = function(r) {
  return j(r != null, "input must be Uint8Array or Buffer"), Te(this, r), this;
};
ct.prototype.digest = function(r) {
  var e = !r || r === "binary" || r === "hex" ? new Uint8Array(this.outlen) : r;
  return j(e.length >= this.outlen, "out must have at least outlen bytes of space"), bs(this, e), r === "hex" ? vs(e) : e;
};
ct.prototype.final = ct.prototype.digest;
ct.ready = function(r) {
  pt.ready(function() {
    r();
  });
};
function Te(r, e) {
  for (var t = 0; t < e.length; t++)
    r.c === 128 && (r.t += r.c, ke(r, !1), r.c = 0), r.b[r.c++] = e[t];
}
function bs(r, e) {
  for (r.t += r.c; r.c < 128; )
    r.b[r.c++] = 0;
  ke(r, !0);
  for (var t = 0; t < r.outlen; t++)
    e[t] = r.h[t >> 2] >> 8 * (t & 3);
  return e;
}
function vs(r) {
  for (var e = "", t = 0; t < r.length; t++)
    e += Ds(r[t]);
  return e;
}
function Ds(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}
var Ue = ct;
Q.exports = function(e, t, s, n, i) {
  return i !== !0 && (j(e >= ue, "outlen must be at least " + ue + ", was given " + e), j(e <= de, "outlen must be at most " + de + ", was given " + e), t != null && j(t.length >= he, "key must be at least " + he + ", was given " + t.length), t != null && j(t.length <= le, "key must be at most " + le + ", was given " + t.length), s != null && j(s.length === Ae, "salt must be exactly " + Ae + ", was given " + s.length), n != null && j(n.length === ge, "personal must be exactly " + ge + ", was given " + n.length)), new Ue(e, t, s, n);
};
Q.exports.ready = function(r) {
  pt.ready(function() {
    r();
  });
};
Q.exports.WASM_SUPPORTED = pt.SUPPORTED;
Q.exports.WASM_LOADED = !1;
var ue = Q.exports.BYTES_MIN = 16, de = Q.exports.BYTES_MAX = 64;
Q.exports.BYTES = 32;
var he = Q.exports.KEYBYTES_MIN = 16, le = Q.exports.KEYBYTES_MAX = 64;
Q.exports.KEYBYTES = 32;
var Ae = Q.exports.SALTBYTES = 16, ge = Q.exports.PERSONALBYTES = 16;
pt.ready(function(r) {
  r || (Q.exports.WASM_LOADED = !0, Ue = pt);
});
var ut = {};
Object.defineProperty(ut, "__esModule", { value: !0 });
ut.bech32m = ut.bech32 = void 0;
const bt = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Pe = {};
for (let r = 0; r < bt.length; r++) {
  const e = bt.charAt(r);
  Pe[e] = r;
}
function ot(r) {
  const e = r >> 25;
  return (r & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function me(r) {
  let e = 1;
  for (let t = 0; t < r.length; ++t) {
    const s = r.charCodeAt(t);
    if (s < 33 || s > 126)
      return "Invalid prefix (" + r + ")";
    e = ot(e) ^ s >> 5;
  }
  e = ot(e);
  for (let t = 0; t < r.length; ++t) {
    const s = r.charCodeAt(t);
    e = ot(e) ^ s & 31;
  }
  return e;
}
function Yt(r, e, t, s) {
  let n = 0, i = 0;
  const o = (1 << t) - 1, c = [];
  for (let u = 0; u < r.length; ++u)
    for (n = n << e | r[u], i += e; i >= t; )
      i -= t, c.push(n >> i & o);
  if (s)
    i > 0 && c.push(n << t - i & o);
  else {
    if (i >= e)
      return "Excess padding";
    if (n << t - i & o)
      return "Non-zero padding";
  }
  return c;
}
function ks(r) {
  return Yt(r, 8, 5, !0);
}
function Ts(r) {
  const e = Yt(r, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function Us(r) {
  const e = Yt(r, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function Ke(r) {
  let e;
  r === "bech32" ? e = 1 : e = 734539939;
  function t(o, c, u) {
    if (u = u || 90, o.length + 7 + c.length > u)
      throw new TypeError("Exceeds length limit");
    o = o.toLowerCase();
    let d = me(o);
    if (typeof d == "string")
      throw new Error(d);
    let A = o + "1";
    for (let l = 0; l < c.length; ++l) {
      const g = c[l];
      if (g >> 5 !== 0)
        throw new Error("Non 5-bit word");
      d = ot(d) ^ g, A += bt.charAt(g);
    }
    for (let l = 0; l < 6; ++l)
      d = ot(d);
    d ^= e;
    for (let l = 0; l < 6; ++l) {
      const g = d >> (5 - l) * 5 & 31;
      A += bt.charAt(g);
    }
    return A;
  }
  function s(o, c) {
    if (c = c || 90, o.length < 8)
      return o + " too short";
    if (o.length > c)
      return "Exceeds length limit";
    const u = o.toLowerCase(), d = o.toUpperCase();
    if (o !== u && o !== d)
      return "Mixed-case string " + o;
    o = u;
    const A = o.lastIndexOf("1");
    if (A === -1)
      return "No separator character for " + o;
    if (A === 0)
      return "Missing prefix for " + o;
    const l = o.slice(0, A), g = o.slice(A + 1);
    if (g.length < 6)
      return "Data too short";
    let I = me(l);
    if (typeof I == "string")
      return I;
    const y = [];
    for (let k = 0; k < g.length; ++k) {
      const z = g.charAt(k), f = Pe[z];
      if (f === void 0)
        return "Unknown character " + z;
      I = ot(I) ^ f, !(k + 6 >= g.length) && y.push(f);
    }
    return I !== e ? "Invalid checksum for " + o : { prefix: l, words: y };
  }
  function n(o, c) {
    const u = s(o, c);
    if (typeof u == "object")
      return u;
  }
  function i(o, c) {
    const u = s(o, c);
    if (typeof u == "object")
      return u;
    throw new Error(u);
  }
  return {
    decodeUnsafe: n,
    decode: i,
    encode: t,
    toWords: ks,
    fromWordsUnsafe: Ts,
    fromWords: Us
  };
}
ut.bech32 = Ke("bech32");
ut.bech32m = Ke("bech32m");
var Ps = ee && ee.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Qe, "__esModule", { value: !0 });
const Ks = Ps(Q.exports), yt = ut, Kt = "asset";
class mt {
  constructor(e) {
    this.hashBuf = e;
  }
  static fromHash(e) {
    return new mt(e);
  }
  static fromParts(e, t) {
    const s = (0, Ks.default)(20).update(new Uint8Array([...e, ...t])).digest("binary");
    return mt.fromHash(s);
  }
  static fromBech32(e) {
    const { prefix: t, words: s } = yt.bech32.decode(e);
    if (t !== Kt)
      throw new Error("Invalid asset fingerprint");
    const n = Buffer.from(yt.bech32.fromWords(s));
    return mt.fromHash(n);
  }
  fingerprint() {
    const e = yt.bech32.toWords(this.hashBuf);
    return yt.bech32.encode(Kt, e);
  }
  hash() {
    return Buffer.from(this.hashBuf).toString("hex");
  }
  prefix() {
    return Kt;
  }
  checksum() {
    return this.fingerprint().slice(-6);
  }
}
var Ns = Qe.default = mt;
const Ms = Ns, Hs = (r, e) => {
  const t = Fs(r), s = t.derive(Pt + 1852).derive(Pt + 1815).derive(Pt + e), n = s.derive(0).derive(0).to_raw_key(), i = s.derive(2).derive(0).to_raw_key();
  return s.free(), t.free(), { paymentKey: n, stakeKey: i };
}, nt = (r) => a.Address.from_bytes(p(r)), Fs = (r) => a.Bip32PrivateKey.from_bytes(p(r)), Os = (r) => a.DataHash.from_bytes(p(r)), H = (r) => a.Ed25519KeyHash.from_bytes(p(r)), Vs = (r) => a.Ed25519Signature.from_bytes(p(r)), Dt = (r) => a.NativeScript.from_bytes(p(r)), Rs = (r) => a.PublicKey.from_bytes(p(r)), Ne = (r) => a.PlutusData.from_bytes(p(r)), dt = (r, e) => a.PlutusScript.from_bytes_with_version(p(r), R[e]), qs = (r) => a.ScriptRef.from_bytes(p(r)), Ys = (r) => a.ScriptHash.from_bytes(p(r)), Y = (r) => a.Transaction.from_bytes(p(r)), Me = (r) => a.TransactionHash.from_bytes(p(r)), Ie = (r) => a.TransactionUnspentOutput.from_bytes(p(r)), Ls = (r) => a.TransactionWitnessSet.from_bytes(p(r)), Gs = (r) => a.Value.from_bytes(p(r)), K = (r) => a.Address.from_bech32(r), Lt = (r) => a.BaseAddress.from_address(K(r)), He = (r) => a.EnterpriseAddress.from_address(K(r)), Fe = (r) => a.RewardAddress.from_address(K(r)), b = (r) => Buffer.from(r).toString("hex"), p = (r) => r.length % 2 === 0 && /^[0-9A-F]*$/i.test(r) ? Buffer.from(r, "hex") : Buffer.from(r, "utf-8"), kt = (r) => {
  const e = (t) => {
    const s = new Array();
    for (let n = 0; n < t.len(); n += 1)
      s.push(kt(t.get(n)));
    return s;
  };
  switch (r.kind()) {
    case a.NativeScriptKind.ScriptAll: {
      const t = r.as_script_all();
      return {
        type: "all",
        scripts: e(t.native_scripts())
      };
    }
    case a.NativeScriptKind.ScriptAny: {
      const t = r.as_script_any();
      return {
        type: "any",
        scripts: e(t.native_scripts())
      };
    }
    case a.NativeScriptKind.ScriptNOfK: {
      const t = r.as_script_n_of_k();
      return {
        type: "atLeast",
        required: t.n(),
        scripts: e(t.native_scripts())
      };
    }
    case a.NativeScriptKind.TimelockStart: {
      const t = r.as_timelock_start();
      return {
        type: "after",
        slot: t.slot_bignum().to_str()
      };
    }
    case a.NativeScriptKind.TimelockExpiry: {
      const t = r.as_timelock_expiry();
      return {
        type: "before",
        slot: t.slot_bignum().to_str()
      };
    }
    case a.NativeScriptKind.ScriptPubkey: {
      const t = r.as_script_pubkey();
      return {
        type: "sig",
        keyHash: t.addr_keyhash().to_hex()
      };
    }
    default:
      throw new Error(`Script Kind: ${r.kind()}, is not supported`);
  }
}, Tt = (r) => {
  const e = (t) => {
    const s = a.NativeScripts.new();
    return t.forEach((n) => {
      s.add(Tt(n));
    }), s;
  };
  switch (r.type) {
    case "all":
      return a.NativeScript.new_script_all(a.ScriptAll.new(e(r.scripts)));
    case "any":
      return a.NativeScript.new_script_any(a.ScriptAny.new(e(r.scripts)));
    case "atLeast":
      return a.NativeScript.new_script_n_of_k(a.ScriptNOfK.new(r.required, e(r.scripts)));
    case "after":
      return a.NativeScript.new_timelock_start(a.TimelockStart.new_timelockstart(a.BigNum.from_str(r.slot)));
    case "before":
      return a.NativeScript.new_timelock_expiry(a.TimelockExpiry.new_timelockexpiry(a.BigNum.from_str(r.slot)));
    case "sig":
      return a.NativeScript.new_script_pubkey(a.ScriptPubkey.new(H(r.keyHash)));
  }
}, St = (r) => {
  var s, n, i;
  const e = (o) => {
    const c = [];
    for (let u = 0; u < o.len(); u += 1)
      c.push(St(o.get(u)));
    return c;
  }, t = (o) => {
    const c = /* @__PURE__ */ new Map();
    for (let u = 0; u < o.len(); u += 1) {
      const d = o.keys().get(u), A = o.get(d) ?? a.PlutusData.from_hex(E("NO_ITEM_FOUND_INSIDE_GOLD_ROOM"));
      c.set(St(d), St(A));
    }
    return c;
  };
  switch (r.kind()) {
    case a.PlutusDataKind.Bytes:
      return b(r.as_bytes() ?? new Uint8Array());
    case a.PlutusDataKind.Integer:
      return parseInt(((s = r.as_integer()) == null ? void 0 : s.to_str()) ?? "0", 10);
    case a.PlutusDataKind.List:
      return e(r.as_list() ?? a.PlutusList.new());
    case a.PlutusDataKind.Map:
      return t(r.as_map() ?? a.PlutusMap.new());
    case a.PlutusDataKind.ConstrPlutusData:
      return {
        alternative: parseInt(((n = r.as_constr_plutus_data()) == null ? void 0 : n.alternative().to_str()) ?? "0", 10),
        fields: e(((i = r.as_constr_plutus_data()) == null ? void 0 : i.data()) ?? a.PlutusList.new())
      };
    default:
      throw new Error(`PlutusData Kind: ${r.kind()}, is not supported`);
  }
}, tt = (r) => {
  const e = (t) => {
    const s = a.PlutusList.new();
    return t.forEach((n) => {
      s.add(tt(n));
    }), s;
  };
  switch (typeof r) {
    case "string":
      return a.PlutusData.new_bytes(p(r));
    case "number":
      return a.PlutusData.new_integer(a.BigInt.from_str(r.toString()));
    case "object":
      if (r instanceof Array) {
        const t = e(r);
        return a.PlutusData.new_list(t);
      } else if (r instanceof Map) {
        const t = a.PlutusMap.new();
        return r.forEach((s, n) => {
          t.insert(tt(n), tt(s));
        }), a.PlutusData.new_map(t);
      } else
        return a.PlutusData.new_constr_plutus_data(a.ConstrPlutusData.new(a.BigNum.from_str(r.alternative.toString()), e(r.fields)));
  }
}, $s = (r) => {
  const e = a.Relays.new();
  throw r.relays.forEach((t) => {
    e.add(zs(t));
  }), new Error("toPoolParams not implemented.");
}, Oe = (r) => {
  const e = (t) => ss[t];
  return a.Redeemer.new(e(r.tag), a.BigNum.from_str(r.index.toString()), tt(r.data), a.ExUnits.new(a.BigNum.from_str(r.budget.mem.toString()), a.BigNum.from_str(r.budget.steps.toString())));
}, zs = (r) => {
  switch (r.type) {
    case "SingleHostAddr": {
      const e = r.IPV4 ? a.Ipv4.new(new Uint8Array(r.IPV4.split(".").map((s) => parseInt(s)))) : void 0, t = r.IPV6 ? a.Ipv6.new(p(r.IPV6.replaceAll(":", ""))) : void 0;
      return a.Relay.new_single_host_addr(a.SingleHostAddr.new(r.port, e, t));
    }
    case "SingleHostName":
      return a.Relay.new_single_host_name(a.SingleHostName.new(r.port, a.DNSRecordAorAAAA.new(r.domainName)));
    case "MultiHostName":
      return a.Relay.new_multi_host_name(a.MultiHostName.new(a.DNSRecordSRV.new(r.domainName)));
  }
}, Ve = (r) => {
  if (r.is_plutus_script()) {
    const t = r.plutus_script();
    return {
      code: t.to_hex(),
      version: Object.keys(R).find((s) => R[s].to_hex() === t.language_version().to_hex())
    };
  }
  const e = r.native_script();
  return kt(e);
}, ht = (r) => {
  if ("code" in r) {
    const e = dt(r.code, r.version);
    return a.ScriptRef.new_plutus_script(e);
  }
  return a.ScriptRef.new_native_script(Tt(r));
}, vt = (r) => {
  var n, i, o;
  const e = r.output().has_data_hash() ? (n = r.output().data_hash()) == null ? void 0 : n.to_hex() : void 0, t = r.output().has_plutus_data() ? (i = r.output().plutus_data()) == null ? void 0 : i.to_hex() : void 0, s = r.output().has_script_ref() ? (o = r.output().script_ref()) == null ? void 0 : o.to_hex() : void 0;
  return {
    input: {
      outputIndex: r.input().index(),
      txHash: r.input().transaction_id().to_hex()
    },
    output: {
      address: r.output().address().to_bech32(),
      amount: Re(r.output().amount()),
      dataHash: e,
      plutusData: t,
      scriptRef: s
    }
  };
}, M = (r) => {
  const e = a.TransactionInput.new(Me(r.input.txHash), r.input.outputIndex), t = a.TransactionOutput.new(K(r.output.address), Z(r.output.amount));
  return r.output.dataHash !== void 0 && t.set_data_hash(Os(r.output.dataHash)), r.output.plutusData !== void 0 && t.set_plutus_data(Ne(r.output.plutusData)), r.output.scriptRef !== void 0 && t.set_script_ref(qs(r.output.scriptRef)), a.TransactionUnspentOutput.new(e, t);
}, pe = (r) => {
  const e = r.split(".")[1] ?? "0", t = `${parseInt(e, 10)}`, s = "1" + "0".repeat(e.length);
  return a.UnitInterval.new(a.BigNum.from_str(t), a.BigNum.from_str(s));
}, E = (r) => r.length % 2 === 0 && /^[0-9A-F]*$/i.test(r) ? r : b(Buffer.from(r, "utf-8")), Gt = (r) => Buffer.from(r, "hex").toString("utf-8"), Re = (r) => {
  const e = [
    { unit: "lovelace", quantity: r.coin().to_str() }
  ], t = r.multiasset();
  if (t !== void 0) {
    const s = t.keys();
    for (let n = 0; n < s.len(); n += 1) {
      const i = s.get(n), o = t.get(i);
      if (o !== void 0) {
        const c = o.keys();
        for (let u = 0; u < c.len(); u += 1) {
          const d = c.get(u), A = o.get(d) ?? a.BigNum.from_str("0"), l = i.to_hex() + b(d.name());
          e.push({ unit: l, quantity: A.to_str() });
        }
      }
    }
  }
  return e;
}, Z = (r) => {
  const e = r.find((i) => i.unit === "lovelace"), t = Array.from(new Set(r.filter((i) => i.unit !== "lovelace").map((i) => i.unit.slice(0, F)))), s = a.MultiAsset.new();
  t.forEach((i) => {
    const o = a.Assets.new();
    r.filter((c) => c.unit.slice(0, F) === i).forEach((c) => {
      o.insert(a.AssetName.new(p(c.unit.slice(F))), a.BigNum.from_str(c.quantity));
    }), s.insert(Ys(i), o);
  });
  const n = a.Value.new(a.BigNum.from_str(e ? e.quantity : "0"));
  return (r.length > 1 || !e) && n.set_multiasset(s), n;
}, fe = (r, e, t) => a.BaseAddress.new(r, a.StakeCredential.from_keyhash(e), a.StakeCredential.from_keyhash(t)), qe = (r, e = "") => a.Bip32PrivateKey.from_bip39_entropy(p(r), p(E(e))), Ht = (r) => a.DataCost.new_coins_per_byte(a.BigNum.from_str(r)), Ws = (r) => {
  if (typeof r != "object" || !("input" in r))
    return a.DatumSource.new(tt(r));
  const e = M(r);
  if (e.output().has_plutus_data())
    return a.DatumSource.new_ref_input(e.input());
  throw new Error(`No inline datum found in UTxO: ${e.input().transaction_id().to_hex()}`);
}, _e = (r, e) => a.EnterpriseAddress.new(r, a.StakeCredential.from_keyhash(e)), ye = (r, e) => {
  if (typeof r == "string")
    return a.MintWitness.new_native_script(Dt(r));
  if (e === void 0)
    throw new Error("Minting with plutus requires a redeemer to be defined");
  if (e.tag !== "MINT")
    throw new Error("Minting redeemer's tag must be defined as 'MINT'");
  return a.MintWitness.new_plutus_script(Ye(r), Oe({
    tag: "MINT",
    index: 0,
    budget: at,
    data: {
      alternative: 0,
      fields: []
    },
    ...e
  }));
}, Ft = (r, e) => a.RewardAddress.new(r, a.StakeCredential.from_keyhash(e)), Ye = (r) => {
  if ("code" in r)
    return a.PlutusScriptSource.new(dt(r.code, r.version));
  const e = M(r);
  if (e.output().has_script_ref()) {
    const t = e.output().script_ref();
    if (t.is_plutus_script()) {
      const s = Ve(t), n = dt(s.code, s.version).hash();
      return a.PlutusScriptSource.new_ref_input_with_lang_ver(n, e.input(), R[s.version]);
    }
  }
  throw new Error(`No plutus script reference found in UTxO: ${e.input().transaction_id().to_hex()}`);
}, xt = (r) => {
  const e = a.ScriptPubkey.new(r);
  return a.NativeScript.new_script_pubkey(e);
}, Et = (r = v) => {
  const e = a.TransactionBuilderConfigBuilder.new().coins_per_utxo_byte(a.BigNum.from_str(r.coinsPerUTxOSize)).ex_unit_prices(a.ExUnitPrices.new(pe(r.priceMem.toString()), pe(r.priceStep.toString()))).fee_algo(a.LinearFee.new(a.BigNum.from_str(r.minFeeA.toString()), a.BigNum.from_str(r.minFeeB.toString()))).key_deposit(a.BigNum.from_str(r.keyDeposit)).max_tx_size(r.maxTxSize).max_value_size(parseInt(r.maxValSize, 10)).pool_deposit(a.BigNum.from_str(r.poolDeposit)).build();
  return a.TransactionBuilder.new(e);
}, xe = (r) => {
  const e = a.TxInputsBuilder.new();
  return r.map((t) => t instanceof a.TransactionUnspentOutput ? t : M(t)).forEach((t) => {
    e.add_input(t.output().address(), t.input(), t.output().amount());
  }), e;
}, Ct = (r) => {
  if (typeof r == "string")
    return a.TransactionOutputBuilder.new().with_address(K(r));
  let e = a.TransactionOutputBuilder.new().with_address(K(r.address));
  if (r.datum) {
    const { value: t, inline: s } = r.datum, n = tt(t);
    e = e.with_data_hash(a.hash_plutus_data(n)), s && (e = e.with_plutus_data(n));
  }
  if (r.script) {
    const t = ht(r.script);
    e = e.with_script_ref(t);
  }
  return e;
}, et = (r) => {
  const e = r.slice(0, F), t = r.includes(".") ? E(r.split(".")[1]) : r.slice(F);
  return { policyId: e, assetName: t };
}, h = (r) => L.isAxiosError(r) ? r.response ? JSON.stringify({
  data: r.response.data,
  headers: r.response.headers,
  status: r.response.status
}) : r.request ? JSON.stringify(r.request) : r.message : JSON.stringify(r), ur = (r) => {
  const e = tt(r);
  return a.hash_plutus_data(e).to_hex();
}, dr = (r, e = Date.now()) => {
  if (Qt[r]) {
    const [t, s, n, i] = Qt[r];
    return parseInt(a.BigNum.from_str(e.toString()).div_floor(a.BigNum.from_str("1000")).checked_sub(a.BigNum.from_str(n)).div_floor(a.BigNum.from_str(i)).checked_add(a.BigNum.from_str(t)).to_str(), 10);
  }
  throw new Error(`Couldn't resolve EpochNo for network: ${r}`);
}, Js = (r, e) => Ms.fromParts(p(r), p(e)).fingerprint(), hr = (r, e) => rs[r][e], lr = (r) => Tt(r).hash().to_hex(), it = (r) => {
  var e, t;
  try {
    const s = [
      (e = Lt(r)) == null ? void 0 : e.payment_cred().to_keyhash(),
      (t = He(r)) == null ? void 0 : t.payment_cred().to_keyhash()
    ].find((n) => n !== void 0);
    if (s !== void 0)
      return s.to_hex();
    throw new Error(`Couldn't resolve payment key hash from address: ${r}`);
  } catch (s) {
    throw new Error(`An error occurred during resolvePaymentKeyHash: ${s}.`);
  }
}, Ar = (r, e = 0) => {
  const t = dt(r.code, r.version);
  return a.EnterpriseAddress.new(e, a.StakeCredential.from_scripthash(t.hash())).to_address().to_bech32();
}, gr = (r) => {
  try {
    const e = He(r), t = e == null ? void 0 : e.payment_cred().to_scripthash();
    if (t !== void 0)
      return t.to_hex();
    throw new Error(`Couldn't resolve script hash from address: ${r}`);
  } catch (e) {
    throw new Error(`An error occurred during resolveScriptHash: ${e}.`);
  }
}, mr = (r) => a.Ed25519KeyHash.from_hex(r).to_bech32("pool1"), Ir = (r) => {
  const e = we(r.join(" ")), t = qe(e), s = t.to_bech32();
  return t.free(), s;
}, pr = (r) => ht(r).to_hex(), fr = (r, e = Date.now()) => {
  if (Qt[r]) {
    const [t, s, n] = Qt[r];
    return a.BigNum.from_str(e.toString()).div_floor(a.BigNum.from_str("1000")).checked_sub(a.BigNum.from_str(n)).checked_add(a.BigNum.from_str(s)).to_str();
  }
  throw new Error(`Couldn't resolve SlotNo for network: ${r}`);
}, Ut = (r) => {
  try {
    const e = K(r), t = Lt(r), s = t == null ? void 0 : t.stake_cred().to_keyhash();
    if (s !== void 0)
      return Ft(e.network_id(), s).to_address().to_bech32();
    throw new Error(`Couldn't resolve reward address from address: ${r}`);
  } catch (e) {
    throw new Error(`An error occurred during resolveRewardAddress: ${e}.`);
  }
}, gt = (r) => {
  var e, t;
  try {
    const s = [
      (e = Lt(r)) == null ? void 0 : e.stake_cred().to_keyhash(),
      (t = Fe(r)) == null ? void 0 : t.payment_cred().to_keyhash()
    ].find((n) => n !== void 0);
    if (s !== void 0)
      return s.to_hex();
    throw new Error(`Couldn't resolve stake key hash from address: ${r}`);
  } catch (s) {
    throw new Error(`An error occurred during resolveStakeKeyHash: ${s}.`);
  }
}, Le = (r, e = v.minFeeA, t = v.minFeeB) => (BigInt(e) * BigInt(r) + BigInt(t)).toString(), js = (r) => {
  const e = Y(r).body();
  return a.hash_transaction(e).to_hex();
}, _r = (r = "", e = 32) => {
  if (e <= 0 || e > 2048)
    throw new Error("Length must be bewteen 1 and 2048");
  const s = Ce("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")(e);
  return E(`${r}${s}`);
}, Ge = (r, e) => {
  const t = r.vkeys();
  if (t !== void 0) {
    const s = /* @__PURE__ */ new Set();
    for (let i = 0; i < t.len(); i += 1)
      s.add(t.get(i).to_hex());
    for (let i = 0; i < e.len(); i += 1)
      s.add(e.get(i).to_hex());
    const n = a.Vkeywitnesses.new();
    return s.forEach((i) => {
      n.add(a.Vkeywitness.from_hex(i));
    }), n;
  }
  return e;
}, yr = (r) => St(Ne(r)), xr = (r) => Y(r).to_js_value();
class Cr {
  _axiosInstance;
  constructor(...e) {
    if (typeof e[0] == "string" && e[0].startsWith("http"))
      this._axiosInstance = L.create({ baseURL: e[0] });
    else {
      const t = e[0], s = t.slice(0, 7);
      this._axiosInstance = L.create({
        baseURL: `https://cardano-${s}.blockfrost.io/api/v${e[1] ?? 0}`,
        headers: { project_id: t }
      });
    }
  }
  async fetchAccountInfo(e) {
    const t = e.startsWith("addr") ? Ut(e) : e;
    try {
      const { data: s, status: n } = await this._axiosInstance.get(`accounts/${t}`);
      if (n === 200)
        return {
          poolId: s.pool_id,
          active: s.active || s.active_epoch !== null,
          balance: s.controlled_amount,
          rewards: s.withdrawable_amount,
          withdrawals: s.withdrawals_sum
        };
      throw h(s);
    } catch (s) {
      throw h(s);
    }
  }
  resolveScriptRef = async (e) => {
    if (e) {
      const { data: t, status: s } = await this._axiosInstance.get(`scripts/${e}`);
      if (s === 200) {
        const n = t.type.startsWith("plutus") ? {
          code: await this.fetchPlutusScriptCBOR(e),
          version: t.type.replace("plutus", "")
        } : await this.fetchNativeScriptJSON(e);
        return ht(n).to_hex();
      }
      throw h(t);
    }
  };
  toUTxO = async (e, t) => ({
    input: {
      outputIndex: e.output_index,
      txHash: t
    },
    output: {
      address: e.address,
      amount: e.amount,
      dataHash: e.data_hash ?? void 0,
      plutusData: e.inline_datum ?? void 0,
      scriptRef: await this.resolveScriptRef(e.reference_script_hash),
      scriptHash: e.reference_script_hash
    }
  });
  async fetchAddressUTxOs(e, t) {
    const s = t !== void 0 ? `/${t}` : "", n = `addresses/${e}/utxos` + s, i = async (o = 1, c = []) => {
      const { data: u, status: d } = await this._axiosInstance.get(`${n}?page=${o}`);
      if (d === 200)
        return u.length > 0 ? i(o + 1, [
          ...c,
          ...await Promise.all(u.map((A) => this.toUTxO(A, A.tx_hash)))
        ]) : c;
      throw h(u);
    };
    try {
      return await i();
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    const t = async (s = 1, n = []) => {
      const { policyId: i, assetName: o } = et(e), { data: c, status: u } = await this._axiosInstance.get(`assets/${i}${o}/addresses?page=${s}`);
      if (u === 200)
        return c.length > 0 ? t(s + 1, [...n, ...c]) : n;
      throw h(c);
    };
    try {
      return await t();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    try {
      const { policyId: t, assetName: s } = et(e), { data: n, status: i } = await this._axiosInstance.get(`assets/${t}${s}`);
      if (i === 200)
        return {
          ...n.onchain_metadata
        };
      throw h(n);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchBlockInfo(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`blocks/${e}`);
      if (s === 200)
        return {
          confirmations: t.confirmations,
          epoch: t.epoch,
          epochSlot: t.epoch_slot.toString(),
          fees: t.fees,
          hash: t.hash,
          nextBlock: t.next_block ?? "",
          operationalCertificate: t.op_cert,
          output: t.output ?? "0",
          previousBlock: t.previous_block,
          size: t.size,
          slot: t.slot.toString(),
          slotLeader: t.slot_leader ?? "",
          time: t.time,
          txCount: t.tx_count,
          VRFKey: t.block_vrf
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchCollectionAssets(e, t = 1) {
    try {
      const { data: s, status: n } = await this._axiosInstance.get(`assets/policy/${e}?page=${t}`);
      if (n === 200)
        return {
          assets: s.map((i) => ({
            unit: i.asset,
            quantity: i.quantity
          })),
          next: s.length === 100 ? t + 1 : null
        };
      throw h(s);
    } catch {
      return { assets: [], next: null };
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = E(e.replace("$", "")), { data: s, status: n } = await this._axiosInstance.get(`assets/${Vt[1]}${t}/addresses`);
      if (n === 200)
        return s[0].address;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchProtocolParameters(e = Number.NaN) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`epochs/${isNaN(e) ? "latest" : e}/parameters`);
      if (s === 200)
        return {
          coinsPerUTxOSize: t.coins_per_utxo_word,
          collateralPercent: t.collateral_percent,
          decentralisation: t.decentralisation_param,
          epoch: t.epoch,
          keyDeposit: t.key_deposit,
          maxBlockExMem: t.max_block_ex_mem,
          maxBlockExSteps: t.max_block_ex_steps,
          maxBlockHeaderSize: t.max_block_header_size,
          maxBlockSize: t.max_block_size,
          maxCollateralInputs: t.max_collateral_inputs,
          maxTxExMem: t.max_tx_ex_mem,
          maxTxExSteps: t.max_tx_ex_steps,
          maxTxSize: t.max_tx_size,
          maxValSize: t.max_val_size,
          minFeeA: t.min_fee_a,
          minFeeB: t.min_fee_b,
          minPoolCost: t.min_pool_cost,
          poolDeposit: t.pool_deposit,
          priceMem: t.price_mem,
          priceStep: t.price_step
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchTxInfo(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`txs/${e}`);
      if (s === 200)
        return {
          block: t.block,
          deposit: t.deposit,
          fees: t.fees,
          hash: t.hash,
          index: t.index,
          invalidAfter: t.invalid_hereafter ?? "",
          invalidBefore: t.invalid_before ?? "",
          slot: t.slot.toString(),
          size: t.size
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchUTxOs(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`txs/${e}/utxos`);
      if (s === 200) {
        const n = t.outputs, i = [];
        return n.forEach((c) => {
          i.push(this.toUTxO(c, e));
        }), await Promise.all(i);
      }
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  onTxConfirmed(e, t, s = 100) {
    let n = 0;
    const i = setInterval(() => {
      n >= s && clearInterval(i), this.fetchTxInfo(e).then((o) => {
        this.fetchBlockInfo(o.block).then((c) => {
          (c == null ? void 0 : c.confirmations) > 0 && (clearInterval(i), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: s, status: n } = await this._axiosInstance.post("tx/submit", p(e), { headers: t });
      if (n === 200)
        return s;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchPlutusScriptCBOR(e) {
    const { data: t, status: s } = await this._axiosInstance.get(`scripts/${e}/cbor`);
    if (s === 200)
      return t.cbor;
    throw h(t);
  }
  async fetchNativeScriptJSON(e) {
    const { data: t, status: s } = await this._axiosInstance.get(`scripts/${e}/json`);
    if (s === 200)
      return t.json;
    throw h(t);
  }
}
class wr {
  _axiosInstance;
  constructor(e, t, s) {
    const n = s.host ?? "ipfs.infura.io", i = s.port ?? 5001, o = s.version ?? 0;
    this._axiosInstance = L.create({
      baseURL: `https://${n}:${i}/api/v${o}`,
      auth: { username: e, password: t }
    });
  }
  async uploadContent(e, t = !1) {
    try {
      const s = { "Content-Type": "multipart/form-data" }, { data: n, status: i } = await this._axiosInstance.post(`add?recursive=${t}`, e, { headers: s });
      if (i === 200)
        return n;
      throw h(n);
    } catch (s) {
      throw h(s);
    }
  }
}
class Br {
  _axiosInstance;
  constructor(...e) {
    typeof e[0] == "string" && e[0].startsWith("http") ? this._axiosInstance = L.create({
      baseURL: e[0],
      headers: {
        Authorization: `Bearer ${e[1]}`
      }
    }) : this._axiosInstance = L.create({
      baseURL: `https://${e[0]}.koios.rest/api/v${e[2] ?? 0}`,
      headers: {
        Authorization: `Bearer ${e[1]}`
      }
    });
  }
  async fetchAccountInfo(e) {
    try {
      const t = e.startsWith("addr") ? Ut(e) : e, { data: s, status: n } = await this._axiosInstance.post("account_info", {
        _stake_addresses: [t]
      });
      if (n === 200)
        return {
          poolId: s[0].delegated_pool,
          active: s[0].status === "registered",
          balance: s[0].total_balance.toString(),
          rewards: s[0].rewards_available,
          withdrawals: s[0].withdrawals
        };
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchAddressUTxOs(e, t) {
    try {
      const { data: s, status: n } = await this._axiosInstance.post("address_info", {
        _addresses: [e]
      });
      if (n === 200) {
        const i = s.flatMap((o) => o.utxo_set).map((o) => this.toUTxO(o, e));
        return t !== void 0 ? i.filter((o) => o.output.amount.find((c) => c.unit === t) !== void 0) : i;
      }
      throw h(s);
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    try {
      const { policyId: t, assetName: s } = et(e), { data: n, status: i } = await this._axiosInstance.get(`asset_address_list?_asset_policy=${t}&_asset_name=${s}`);
      if (i === 200)
        return n.map((o) => ({
          address: o.payment_address,
          quantity: o.quantity
        }));
      throw h(n);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchAssetMetadata(e) {
    try {
      const { policyId: t, assetName: s } = et(e), { data: n, status: i } = await this._axiosInstance.get(`asset_info?_asset_policy=${t}&_asset_name=${s}`);
      if (i === 200)
        return {
          ...n[0].minting_tx_metadata[721][t][Gt(s)]
        };
      throw h(n);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchBlockInfo(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.post("block_info", {
        _block_hashes: [e]
      });
      if (s === 200)
        return {
          confirmations: t[0].num_confirmations,
          epoch: t[0].epoch_no,
          epochSlot: t[0].epoch_slot.toString(),
          fees: t[0].total_fees ?? "",
          hash: t[0].hash,
          nextBlock: t[0].child_hash ?? "",
          operationalCertificate: t[0].op_cert,
          output: t[0].total_output ?? "0",
          previousBlock: t[0].parent_hash,
          size: t[0].block_size,
          slot: t[0].abs_slot.toString(),
          slotLeader: t[0].pool ?? "",
          time: t[0].block_time,
          txCount: t[0].tx_count,
          VRFKey: t[0].vrf_key
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchCollectionAssets(e, t = 0) {
    try {
      const { data: s, status: n } = await this._axiosInstance.get(`asset_policy_info?_asset_policy=${e}&limit=100&offset=${t}`);
      if (n === 200)
        return {
          assets: s.map((i) => ({
            unit: `${e}${i.asset_name}`,
            quantity: i.total_supply
          })),
          next: s.length === 100 ? t + 100 : null
        };
      throw h(s);
    } catch (s) {
      throw h(s);
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = E(e.replace("$", "")), { data: s, status: n } = await this._axiosInstance.get(`asset_address_list?_asset_policy=${Vt[1]}&_asset_name=${t}`);
      if (n === 200)
        return s[0].payment_address;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchProtocolParameters(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`epoch_params?_epoch_no=${e}`);
      if (s === 200)
        return {
          coinsPerUTxOSize: t[0].coins_per_utxo_size,
          collateralPercent: t[0].collateral_percent,
          decentralisation: t[0].decentralisation,
          epoch: t[0].epoch_no,
          keyDeposit: t[0].key_deposit,
          maxBlockExMem: t[0].max_block_ex_mem.toString(),
          maxBlockExSteps: t[0].max_block_ex_steps.toString(),
          maxBlockHeaderSize: t[0].max_bh_size,
          maxBlockSize: t[0].max_block_size,
          maxCollateralInputs: t[0].max_collateral_inputs,
          maxTxExMem: t[0].max_tx_ex_mem.toString(),
          maxTxExSteps: t[0].max_tx_ex_steps.toString(),
          maxTxSize: t[0].max_tx_size,
          maxValSize: t[0].max_val_size.toString(),
          minFeeA: t[0].min_fee_a,
          minFeeB: t[0].min_fee_b,
          minPoolCost: t[0].min_pool_cost,
          poolDeposit: t[0].pool_deposit,
          priceMem: t[0].price_mem,
          priceStep: t[0].price_step
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchTxInfo(e) {
    var t, s;
    try {
      const { data: n, status: i } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [e]
      });
      if (i === 200)
        return {
          block: n[0].block_hash,
          deposit: n[0].deposit,
          fees: n[0].fee,
          hash: n[0].tx_hash,
          index: n[0].tx_block_index,
          invalidAfter: ((t = n[0].invalid_after) == null ? void 0 : t.toString()) ?? "",
          invalidBefore: ((s = n[0].invalid_before) == null ? void 0 : s.toString()) ?? "",
          slot: n[0].absolute_slot.toString(),
          size: n[0].tx_size
        };
      throw h(n);
    } catch (n) {
      throw h(n);
    }
  }
  async fetchUTxOs(e) {
    try {
      console.log("hi");
      const { data: t, status: s } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [e]
      });
      if (s === 200)
        return console.log(t[0]), t[0].outputs.map((i) => this.toUTxO(i, i.payment_addr.bech32));
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  onTxConfirmed(e, t, s = 100) {
    let n = 0;
    const i = setInterval(() => {
      n >= s && clearInterval(i), this.fetchTxInfo(e).then((o) => {
        this.fetchBlockInfo(o.block).then((c) => {
          (c == null ? void 0 : c.confirmations) > 0 && (clearInterval(i), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: s, status: n } = await this._axiosInstance.post("submittx", p(e), { headers: t });
      if (n === 202)
        return s;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  toUTxO(e, t) {
    var s, n;
    return {
      input: {
        outputIndex: e.tx_index,
        txHash: e.tx_hash
      },
      output: {
        address: t,
        amount: [
          { unit: "lovelace", quantity: e.value },
          ...e.asset_list.map((i) => ({
            unit: `${i.policy_id}${i.asset_name}`,
            quantity: `${i.quantity}`
          }))
        ],
        dataHash: e.datum_hash ?? void 0,
        plutusData: ((s = e.inline_datum) == null ? void 0 : s.bytes) ?? void 0,
        scriptRef: this.resolveScriptRef(e.reference_script),
        scriptHash: ((n = e.reference_script) == null ? void 0 : n.hash) ?? void 0
      }
    };
  }
  resolveScriptRef = (e) => {
    if (e) {
      const t = e.type.startsWith("plutus") ? {
        code: e.bytes,
        version: e.type.replace("plutus", "")
      } : kt(Dt(e.bytes));
      return ht(t).to_hex();
    }
  };
}
class Sr {
  _baseUrl;
  constructor(...e) {
    this._baseUrl = es(e[0]) ? ns[e[0]] : e[0];
  }
  async evaluateTx(e) {
    const t = await this.open();
    return this.send(t, "EvaluateTx", {
      evaluate: e
    }), new Promise((s, n) => {
      t.addEventListener("message", (i) => {
        try {
          const { result: o } = JSON.parse(i.data);
          o.EvaluationResult ? s(Object.keys(o.EvaluationResult).map((c) => ({
            index: parseInt(c.split(":")[1], 10),
            tag: c.split(":")[0].toUpperCase(),
            budget: {
              mem: o.EvaluationResult[c].memory,
              steps: o.EvaluationResult[c].steps
            }
          }))) : n(o.EvaluationFailure), t.close();
        } catch (o) {
          n(o);
        }
      }, { once: !0 });
    });
  }
  async onNextTx(e) {
    const t = await this.open();
    return this.send(t, "AwaitAcquire", {}), t.addEventListener("message", (s) => {
      const { result: n } = JSON.parse(s.data);
      if (n === null)
        return this.send(t, "AwaitAcquire", {});
      n.AwaitAcquired === void 0 && e(n), this.send(t, "NextTx", {});
    }), () => t.close();
  }
  async submitTx(e) {
    const t = await this.open();
    return this.send(t, "SubmitTx", {
      submit: e
    }), new Promise((s, n) => {
      t.addEventListener("message", (i) => {
        try {
          const { result: o } = JSON.parse(i.data);
          o.SubmitSuccess ? s(o.SubmitSuccess.txId) : n(o.SubmitFail), t.close();
        } catch (o) {
          n(o);
        }
      }, { once: !0 });
    });
  }
  async open() {
    const e = new WebSocket(this._baseUrl);
    return await new Promise((t) => {
      e.addEventListener("open", () => t(!0), { once: !0 });
    }), e;
  }
  send(e, t, s) {
    e.send(JSON.stringify({
      version: "1.0",
      type: "jsonwsp/request",
      servicename: "ogmios",
      methodname: t,
      args: s
    }));
  }
}
class Er {
  _axiosInstance;
  constructor(e, t, s, n = 1) {
    this._axiosInstance = L.create({
      baseURL: `https://cardano-${e}.tangocrypto.com/${t}/v${n}`,
      headers: { "x-api-key": s }
    });
  }
  async evaluateTx(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.post("transactions/evaluate", { tx: e, utxos: [] });
      if (s === 200)
        return t.redeemers.map((n) => ({
          index: n.index,
          tag: n.purpose.toUpperCase(),
          budget: {
            mem: n.unit_mem,
            steps: n.unit_steps
          }
        }));
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchAccountInfo(e) {
    try {
      const t = e.startsWith("addr") ? Ut(e) : e, { data: s, status: n } = await this._axiosInstance.get(`wallets/${t}`);
      if (n === 200)
        return {
          poolId: s.pool_id,
          active: s.active,
          balance: s.controlled_total_stake,
          rewards: s.rewards_sum,
          withdrawals: s.withdrawals_sum
        };
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchAddressUTxOs(e, t) {
    const s = t !== void 0 ? `/assets/${t}` : "", n = `addresses/${e}${s}/utxos?size=50`, i = async (d = "", A = []) => {
      var I;
      const { data: l, status: g } = await this._axiosInstance.get(`${n}&cursor=${d}`);
      if (g === 200)
        return l.cursor !== null && ((I = l.cursor) == null ? void 0 : I.length) > 0 ? i(l.cursor, [...A, ...l.data.map(u)]) : l.data.map(u);
      throw h(l);
    }, o = (d, A) => {
      const l = [
        {
          unit: "lovelace",
          quantity: d.toString()
        }
      ];
      return A.forEach((g) => {
        const I = E(g.asset_name);
        l.push({
          unit: `${g.policy_id}${I}`,
          quantity: g.quantity.toString()
        });
      }), l;
    }, c = (d) => {
      if (d) {
        const A = d.type.startsWith("plutus") ? {
          code: d.code,
          version: d.type.replace("plutus", "")
        } : kt(Dt(d.json));
        return ht(A).to_hex();
      }
    }, u = (d) => {
      var A;
      return {
        input: {
          outputIndex: d.index,
          txHash: d.hash
        },
        output: {
          address: e,
          amount: o(d.value, d.assets),
          dataHash: void 0,
          plutusData: ((A = d.inline_datum) == null ? void 0 : A.value_raw) ?? void 0,
          scriptRef: c(d.reference_script)
        }
      };
    };
    try {
      return await i();
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    const t = (n) => ({
      address: n.address,
      quantity: n.quantity.toString()
    }), s = async (n = "", i = []) => {
      var A;
      const { policyId: o, assetName: c } = et(e), { data: u, status: d } = await this._axiosInstance.get(`assets/${o}${c}/addresses?size=100&cursor=${n}`);
      if (d === 200)
        return u.cursor !== null && ((A = u.cursor) == null ? void 0 : A.length) > 0 ? s(u.cursor, [
          ...i,
          ...u.data.map(t)
        ]) : u.data.map(t);
      throw h(u);
    };
    try {
      return await s();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    var t;
    try {
      const { policyId: s, assetName: n } = et(e), { data: i, status: o } = await this._axiosInstance.get(`assets/${s}${n}`);
      if (o === 200)
        return {
          ...(t = i.metadata.find((c) => c.label === 721)) == null ? void 0 : t.json[s][Gt(n)]
        };
      throw h(i);
    } catch (s) {
      throw h(s);
    }
  }
  async fetchBlockInfo(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`blocks/${e}`);
      if (s === 200)
        return {
          confirmations: t.confirmations,
          epoch: t.epoch_no,
          epochSlot: t.epoch_slot_no.toString(),
          fees: t.fees.toString(),
          hash: t.hash,
          nextBlock: t.next_block.toString() ?? "",
          operationalCertificate: t.op_cert,
          output: t.out_sum.toString() ?? "0",
          previousBlock: t.previous_block.toString(),
          size: t.size,
          slot: t.slot_no.toString(),
          slotLeader: t.slot_leader ?? "",
          time: Date.parse(t.time),
          txCount: t.tx_count,
          VRFKey: t.vrf_key
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchCollectionAssets(e, t = "") {
    try {
      const { data: s, status: n } = await this._axiosInstance.get(`policies/${e}/assets?size=100&cursor=${t}`);
      if (n === 200)
        return {
          assets: s.data.map((i) => ({
            unit: `${i.policy_id}${i.asset_name}`,
            quantity: i.quantity
          })),
          next: s.cursor
        };
      throw h(s);
    } catch {
      return { assets: [], next: null };
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = E(e.replace("$", "")), { data: s, status: n } = await this._axiosInstance.get(`assets/${Vt[1]}${t}/addresses`);
      if (n === 200)
        return s.data[0].address;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchProtocolParameters(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`epochs/${e}/parameters`);
      if (s === 200)
        return {
          coinsPerUTxOSize: t.coins_per_utxo_size.toString(),
          collateralPercent: t.collateral_percent,
          decentralisation: t.decentralisation,
          epoch: t.epoch_no,
          keyDeposit: t.key_deposit.toString(),
          maxBlockExMem: t.max_block_ex_mem.toString(),
          maxBlockExSteps: t.max_block_ex_steps.toString(),
          maxBlockHeaderSize: t.max_block_header_size,
          maxBlockSize: t.max_block_size,
          maxCollateralInputs: t.max_collateral_inputs,
          maxTxExMem: t.max_tx_ex_mem.toString(),
          maxTxExSteps: t.max_tx_ex_steps.toString(),
          maxTxSize: t.max_tx_size,
          maxValSize: t.max_val_size.toString(),
          minFeeA: t.min_fee_a,
          minFeeB: t.min_fee_b,
          minPoolCost: t.min_pool_cost.toString(),
          poolDeposit: t.pool_deposit.toString(),
          priceMem: t.price_mem,
          priceStep: t.price_step
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchTxInfo(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`transactions/${e}`);
      if (s === 200)
        return {
          block: t.block.hash,
          deposit: t.deposit,
          fees: t.fee,
          hash: t.hash,
          index: t.block_index,
          invalidAfter: t.invalid_hereafter ?? "",
          invalidBefore: t.invalid_before ?? "",
          slot: t.block.slot_no.toString(),
          size: t.size
        };
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchUTxOs(e) {
    try {
      return [];
    } catch (t) {
      throw h(t);
    }
  }
  onTxConfirmed(e, t, s = 100) {
    let n = 0;
    const i = setInterval(() => {
      n >= s && clearInterval(i), this.fetchTxInfo(e).then((o) => {
        this.fetchBlockInfo(o.block).then((c) => {
          (c == null ? void 0 : c.confirmations) > 0 && (clearInterval(i), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/json" }, { data: s, status: n } = await this._axiosInstance.post("transactions/submit", { tx: e }, { headers: t });
      if (n === 200)
        return s.tx_id;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
}
class Qr {
  _axiosInstance;
  _amountsAsStrings = {
    headers: {
      "amounts-as-strings": "true"
    }
  };
  submitUrl;
  constructor({ network: e, apiKey: t, turboSubmit: s = !1 }) {
    this._axiosInstance = L.create({
      baseURL: `https://${e}.gomaestro-api.org/v1`,
      headers: { "api-key": t }
    }), this.submitUrl = s ? "txmanager/turbosubmit" : "txmanager";
  }
  async evaluateTx(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.post("transactions/evaluate", { cbor: e });
      if (s === 200) {
        const n = {
          spend: "SPEND",
          mint: "MINT",
          cert: "CERT",
          wdrl: "REWARD"
        };
        return t.map((o) => {
          const c = o.ex_units, u = o.redeemer_index, d = n[o.redeemer_tag];
          return { budget: c, index: u, tag: d };
        });
      }
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchAccountInfo(e) {
    const t = e.startsWith("addr") ? Ut(e) : e;
    try {
      const { data: s, status: n } = await this._axiosInstance.get(`accounts/${t}`, this._amountsAsStrings);
      if (n === 200) {
        const i = s.data;
        return {
          poolId: i.delegated_pool,
          active: i.registered,
          balance: i.total_balance,
          rewards: i.rewards_available,
          withdrawals: i.total_withdrawn
        };
      }
      throw h(s);
    } catch (s) {
      throw h(s);
    }
  }
  async fetchAddressUTxOs(e, t) {
    const s = (() => e.startsWith("addr_vkh") || e.startsWith("addr_shared_vkh") ? `addresses/cred/${e}` : `addresses/${e}`)(), n = t ? `&asset=${t}` : "", i = async (o = null, c = []) => {
      const u = o === null ? "" : `&cursor=${o}`, { data: d, status: A } = await this._axiosInstance.get(`${s}/utxos?count=100${n}${u}`, this._amountsAsStrings);
      if (A === 200) {
        const g = d.data.map(this.toUTxO), I = [...c, ...g], y = d.next_cursor;
        return y == null ? I : i(y, I);
      }
      throw h(d);
    };
    try {
      return await i();
    } catch {
      return [];
    }
  }
  async fetchAssetAddresses(e) {
    const { policyId: t, assetName: s } = et(e), n = async (i = null, o = []) => {
      const c = i === null ? "" : `&cursor=${i}`, { data: u, status: d } = await this._axiosInstance.get(`assets/${t}${s}/addresses?count=100${c}`, this._amountsAsStrings);
      if (d === 200) {
        const l = u.data.map((y) => ({ address: y.address, quantity: y.amount })), g = u.next_cursor, I = [
          ...o,
          ...l
        ];
        return g == null ? I : n(g, I);
      }
      throw h(u);
    };
    try {
      return await n();
    } catch {
      return [];
    }
  }
  async fetchAssetMetadata(e) {
    try {
      const { policyId: t, assetName: s } = et(e), { data: n, status: i } = await this._axiosInstance.get(`assets/${t}${s}`);
      if (i === 200) {
        const o = n.data;
        return {
          ...o.asset_standards.cip25_metadata,
          ...o.asset_standards.cip68_metadata
        };
      }
      throw h(n);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchBlockInfo(e) {
    var t;
    try {
      const { data: s, status: n } = await this._axiosInstance.get(`blocks/${e}`, this._amountsAsStrings);
      if (n === 200) {
        const i = s.data;
        return {
          confirmations: i.confirmations,
          epoch: i.epoch,
          epochSlot: i.epoch_slot.toString(),
          fees: i.total_fees,
          hash: i.hash,
          nextBlock: i.next_block ?? "",
          operationalCertificate: (t = i.operational_certificate) == null ? void 0 : t.hot_vkey,
          output: i.total_output_lovelace ?? "0",
          previousBlock: i.previous_block,
          size: i.size,
          slot: i.absolute_slot.toString(),
          slotLeader: i.block_producer ?? "",
          time: Date.parse(i.timestamp) / 1e3,
          txCount: i.tx_hashes.length,
          VRFKey: a.VRFVKey.from_hex(i.vrf_key).to_bech32("vrf_vk")
        };
      }
      throw h(s);
    } catch (s) {
      throw h(s);
    }
  }
  async fetchCollectionAssets(e, t) {
    try {
      const { data: s, status: n } = await this._axiosInstance.get(`policy/${e}/assets?count=100${t ? `&cursor=${t}` : ""}`);
      if (n === 200)
        return {
          assets: s.data.map((o) => ({
            unit: e + o.asset_name,
            quantity: o.total_supply
          })),
          next: s.next_cursor
        };
      throw h(s);
    } catch {
      return { assets: [], next: null };
    }
  }
  async fetchHandleAddress(e) {
    try {
      const t = e.charAt(0) === "$" ? e.substring(1) : e, { data: s, status: n } = await this._axiosInstance.get(`ecosystem/adahandle/${t}`);
      if (n === 200)
        return s.data;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchProtocolParameters(e = Number.NaN) {
    if (!isNaN(e))
      throw new Error("Maestro only supports fetching Protocol parameters of the latest completed epoch.");
    const t = (s) => {
      const n = s.indexOf("/");
      return parseInt(s.slice(0, n)) / parseInt(s.slice(n + 1));
    };
    try {
      const { data: s, status: n } = await this._axiosInstance.get("protocol-params");
      if (n === 200) {
        const i = s.data;
        try {
          const { data: o, status: c } = await this._axiosInstance.get("epochs/current");
          if (c === 200) {
            const u = o.data;
            return {
              coinsPerUTxOSize: i.coins_per_utxo_byte.toString(),
              collateralPercent: parseInt(i.collateral_percentage),
              decentralisation: 0,
              epoch: parseInt(u.epoch_no),
              keyDeposit: i.stake_key_deposit.toString(),
              maxBlockExMem: i.max_execution_units_per_block.memory.toString(),
              maxBlockExSteps: i.max_execution_units_per_block.steps.toString(),
              maxBlockHeaderSize: parseInt(i.max_block_header_size),
              maxBlockSize: parseInt(i.max_block_body_size),
              maxCollateralInputs: parseInt(i.max_collateral_inputs),
              maxTxExMem: i.max_execution_units_per_transaction.memory.toString(),
              maxTxExSteps: i.max_execution_units_per_transaction.steps.toString(),
              maxTxSize: parseInt(i.max_tx_size),
              maxValSize: i.max_value_size.toString(),
              minFeeA: i.min_fee_coefficient,
              minFeeB: i.min_fee_constant,
              minPoolCost: i.min_pool_cost.toString(),
              poolDeposit: i.pool_deposit.toString(),
              priceMem: t(i.prices.memory),
              priceStep: t(i.prices.steps)
            };
          }
          throw h(o);
        } catch (o) {
          throw h(o);
        }
      }
      throw h(s);
    } catch (s) {
      throw h(s);
    }
  }
  async fetchTxInfo(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`transactions/${e}`);
      if (s === 200) {
        const n = t.data;
        return {
          block: n.block_hash,
          deposit: n.deposit.toString(),
          fees: n.fee.toString(),
          hash: n.tx_hash,
          index: n.block_tx_index,
          invalidAfter: n.invalid_hereafter ?? "",
          invalidBefore: n.invalid_before ?? "",
          slot: n.block_absolute_slot.toString(),
          size: n.size - 1
        };
      }
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  async fetchUTxOs(e) {
    try {
      const { data: t, status: s } = await this._axiosInstance.get(`transactions/${e}`, this._amountsAsStrings);
      if (s === 200)
        return t.data.outputs.map(this.toUTxO);
      throw h(t);
    } catch (t) {
      throw h(t);
    }
  }
  onTxConfirmed(e, t, s = 100) {
    let n = 0;
    const i = setInterval(() => {
      n >= s && clearInterval(i), this.fetchTxInfo(e).then((o) => {
        this.fetchBlockInfo(o.block).then((c) => {
          (c == null ? void 0 : c.confirmations) > 0 && (clearInterval(i), t());
        }).catch(() => {
          n += 1;
        });
      }).catch(() => {
        n += 1;
      });
    }, 5e3);
  }
  async submitTx(e) {
    try {
      const t = { "Content-Type": "application/cbor" }, { data: s, status: n } = await this._axiosInstance.post(this.submitUrl, p(e), { headers: t });
      if (n === 202)
        return s;
      throw h(s);
    } catch (t) {
      throw h(t);
    }
  }
  toUTxO = (e) => {
    var t, s, n;
    return {
      input: {
        outputIndex: e.index,
        txHash: e.tx_hash
      },
      output: {
        address: e.address,
        amount: e.assets.map((i) => ({
          unit: i.unit,
          quantity: i.amount
        })),
        dataHash: (t = e.datum) == null ? void 0 : t.hash,
        plutusData: (s = e.datum) == null ? void 0 : s.bytes,
        scriptRef: this.resolveScript(e),
        scriptHash: (n = e.reference_script) == null ? void 0 : n.hash
      }
    };
  };
  resolveScript = (e) => {
    if (e.reference_script) {
      const t = e.reference_script.type === "native" ? e.reference_script.json : {
        code: e.reference_script.bytes,
        version: e.reference_script.type.replace("plutusv", "V")
      };
      return ht(t).to_hex();
    } else
      return;
  };
}
class br {
  static withOneSignature(e) {
    const t = H(it(e));
    return xt(t).to_hex();
  }
  static withAtLeastNSignatures(e, t) {
    const s = a.NativeScripts.new();
    e.forEach((i) => {
      const o = H(it(i));
      s.add(xt(o));
    });
    const n = a.ScriptNOfK.new(t, s);
    return a.NativeScript.new_script_any(n).to_hex();
  }
  static withAnySignature(e) {
    const t = a.NativeScripts.new();
    e.forEach((n) => {
      const i = H(it(n));
      t.add(xt(i));
    });
    const s = a.ScriptAny.new(t);
    return a.NativeScript.new_script_any(s).to_hex();
  }
  static withAllSignatures(e) {
    const t = a.NativeScripts.new();
    e.forEach((n) => {
      const i = H(it(n));
      t.add(xt(i));
    });
    const s = a.ScriptAll.new(t);
    return a.NativeScript.new_script_any(s).to_hex();
  }
  static fromNativeScript(e) {
    return Tt(e).to_hex();
  }
}
function st(r, e, t, s) {
  var n = arguments.length, i = n < 3 ? e : s === null ? s = Object.getOwnPropertyDescriptor(e, t) : s, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    i = Reflect.decorate(r, e, t, s);
  else
    for (var c = r.length - 1; c >= 0; c--)
      (o = r[c]) && (i = (n < 3 ? o(i) : n > 3 ? o(e, t, i) : o(e, t)) || i);
  return n > 3 && i && Object.defineProperty(e, t, i), i;
}
const Xs = (r) => class extends r {
  __visits = [];
}, rt = () => function(r, e, t) {
  const s = t.value;
  t.value = function(...n) {
    const i = s.call(this, ...n);
    return this.__visits && this.__visits.push(e), i;
  };
};
let $ = class {
  _changeAddress;
  _txOutputs = /* @__PURE__ */ new Map();
  _recipients = /* @__PURE__ */ new Map();
  _totalBurns = /* @__PURE__ */ new Map();
  _totalMints = /* @__PURE__ */ new Map();
  _era;
  _initiator;
  _mintBuilder;
  _protocolParameters;
  _txBuilder;
  _txCertificates;
  _txInputsBuilder;
  _txWithdrawals;
  constructor(e = {}) {
    this._era = e.era, this._initiator = e.initiator, this._mintBuilder = a.MintBuilder.new(), this._protocolParameters = e.parameters ?? v, this._txBuilder = Et(e.parameters), this._txCertificates = a.Certificates.new(), this._txInputsBuilder = a.TxInputsBuilder.new(), this._txWithdrawals = a.Withdrawals.new();
  }
  static maskMetadata(e, t = "BABBAGE") {
    var i;
    const s = Y(e), n = (i = s.auxiliary_data()) == null ? void 0 : i.metadata();
    if (n !== void 0) {
      const o = a.GeneralTransactionMetadata.new();
      for (let u = 0; u < n.len(); u += 1) {
        const d = n.keys().get(u), A = n.get(d);
        o.insert(d, a.TransactionMetadatum.from_hex("0".repeat(((A == null ? void 0 : A.to_hex()) ?? "").length)));
      }
      const c = s.auxiliary_data();
      return c !== void 0 && (c.set_metadata(o), c.set_prefer_alonzo_format(t === "ALONZO")), a.Transaction.new(s.body(), s.witness_set(), c).to_hex();
    }
    return e;
  }
  static readMetadata(e) {
    var s, n;
    return ((n = (s = Y(e).auxiliary_data()) == null ? void 0 : s.metadata()) == null ? void 0 : n.to_hex()) ?? "";
  }
  static writeMetadata(e, t, s = "BABBAGE") {
    const n = Y(e), i = n.auxiliary_data() ?? a.AuxiliaryData.new();
    return i.set_metadata(a.GeneralTransactionMetadata.from_hex(t)), i.set_prefer_alonzo_format(s === "ALONZO"), a.Transaction.new(n.body(), n.witness_set(), i).to_hex();
  }
  get size() {
    return this._txBuilder.full_size();
  }
  async build() {
    try {
      return (this._mintBuilder.has_plutus_scripts() || this.notVisited("redeemValue") === !1) && (await this.addRequiredSignersIfNeeded(), await this.addCollateralIfNeeded()), await this.forgeAssetsIfNeeded(), await this.addTxInputsAsNeeded(), await this.addChangeAddress(), this._txBuilder.build_tx().to_hex();
    } catch (e) {
      throw new Error(`[Transaction] An error occurred during build: ${e}.`);
    }
  }
  burnAsset(e, t, s) {
    const n = this._totalBurns.has(t.unit) ? a.BigNum.from_str(this._totalBurns.get(t.unit) ?? "0").checked_add(a.BigNum.from_str(t.quantity)).to_str() : t.quantity;
    return this._mintBuilder.add_asset(ye(e, s), a.AssetName.new(p(t.unit.slice(F))), a.Int.new_negative(a.BigNum.from_str(t.quantity))), this._totalBurns.set(t.unit, n), this;
  }
  delegateStake(e, t) {
    const s = a.Certificate.new_stake_delegation(a.StakeDelegation.new(a.StakeCredential.from_keyhash(H(gt(e))), a.Ed25519KeyHash.from_bech32(t)));
    return this._txCertificates.add(s), this;
  }
  deregisterStake(e) {
    const t = a.Certificate.new_stake_deregistration(a.StakeDeregistration.new(a.StakeCredential.from_keyhash(H(gt(e)))));
    return this._txCertificates.add(t), this;
  }
  mintAsset(e, t, s) {
    var d, A;
    const n = (l, g) => {
      const I = typeof l == "string" ? Dt(l).hash().to_hex() : i(l).hash().to_hex(), y = E(g.assetName);
      return {
        unit: `${I}${y}`,
        quantity: g.assetQuantity
      };
    }, i = (l) => {
      if ("code" in l)
        return dt(l.code, l.version);
      const g = M(l);
      if (g.output().has_script_ref()) {
        const I = g.output().script_ref();
        if (I.is_plutus_script()) {
          const y = Ve(I);
          return dt(y.code, y.version);
        }
      }
      throw new Error(`No plutus script reference found in UTxO: ${g.input().transaction_id().to_hex()}`);
    }, o = n(e, t), u = a.BigNum.from_str(((d = this._totalMints.get(o.unit)) == null ? void 0 : d.assetQuantity) ?? "0").checked_add(a.BigNum.from_str(o.quantity));
    return this._mintBuilder.add_asset(ye(e, s), a.AssetName.new(p(E(t.assetName))), a.Int.new(a.BigNum.from_str(o.quantity))), this._recipients.has(t.recipient) ? (A = this._recipients.get(t.recipient)) == null || A.push(o) : this._recipients.set(t.recipient, [o]), this._totalMints.set(o.unit, {
      ...t,
      assetQuantity: u.to_str()
    }), this;
  }
  redeemValue(e) {
    const t = {
      tag: "SPEND",
      budget: at,
      index: this._txInputsBuilder.inputs().len(),
      data: {
        alternative: 0,
        fields: []
      },
      ...e.redeemer
    }, s = M(e.value), n = a.PlutusWitness.new_with_ref(Ye(e.script), Ws(e.datum), Oe(t));
    return this._txInputsBuilder.add_plutus_script_input(n, s.input(), s.output().amount()), this;
  }
  registerStake(e) {
    const t = a.Certificate.new_stake_registration(a.StakeRegistration.new(a.StakeCredential.from_keyhash(H(gt(e)))));
    return this._txCertificates.add(t), this;
  }
  registerPool(e) {
    const t = a.Certificate.new_pool_registration(a.PoolRegistration.new($s(e)));
    return this._txCertificates.add(t), this;
  }
  retirePool(e, t) {
    const s = a.Certificate.new_pool_retirement(a.PoolRetirement.new(a.Ed25519KeyHash.from_bech32(e), t));
    return this._txCertificates.add(s), this;
  }
  sendAssets(e, t) {
    const s = Z(t), n = s.multiasset();
    if (s.is_zero() || n === void 0)
      return this;
    const i = Ct(e).next(), o = s.coin().is_zero() ? i.with_asset_and_min_required_coin_by_utxo_cost(n, Ht(this._protocolParameters.coinsPerUTxOSize)).build() : i.with_coin_and_asset(s.coin(), n).build();
    return t.forEach((c) => {
      this.setTxOutput(c);
    }), this._txBuilder.add_output(o), this;
  }
  sendLovelace(e, t) {
    const n = Ct(e).next().with_coin(a.BigNum.from_str(t)).build();
    return this.setTxOutput({
      unit: "lovelace",
      quantity: t
    }), this._txBuilder.add_output(n), this;
  }
  sendToken(e, t, s) {
    return this.sendAssets(e, [{
      quantity: s,
      unit: as[t]
    }]), this;
  }
  sendValue(e, t) {
    const s = Z(t.output.amount), i = Ct(e).next().with_value(s).build();
    return t.output.amount.forEach((o) => {
      this.setTxOutput(o);
    }), this._txBuilder.add_output(i), this;
  }
  setChangeAddress(e) {
    return this._changeAddress = K(e), this;
  }
  setCollateral(e) {
    const t = xe(e);
    return this._txBuilder.set_collateral(t), this;
  }
  setMetadata(e, t) {
    return this._txBuilder.add_json_metadatum_with_schema(a.BigNum.from_str(e.toString()), JSON.stringify(t), a.MetadataJsonSchema.NoConversions), this;
  }
  setRequiredSigners(e) {
    return Array.from(new Set(e.map((s) => s.startsWith("addr") ? it(s) : gt(s)).map((s) => H(s)))).forEach((s) => {
      this._txBuilder.add_required_signer(s);
    }), this;
  }
  setTimeToStart(e) {
    return this._txBuilder.set_validity_start_interval_bignum(a.BigNum.from_str(e)), this;
  }
  setTimeToExpire(e) {
    return this._txBuilder.set_ttl_bignum(a.BigNum.from_str(e)), this;
  }
  setTxInputs(e) {
    return e.map((t) => M(t)).forEach((t) => {
      this._txInputsBuilder.add_input(t.output().address(), t.input(), t.output().amount());
    }), this;
  }
  setTxRefInputs(e) {
    return e.map((t) => M(t)).forEach((t) => {
      this._txBuilder.add_reference_input(t.input());
    }), this;
  }
  withdrawRewards(e, t) {
    const s = Fe(e);
    return s !== void 0 && this._txWithdrawals.insert(s, a.BigNum.from_str(t)), this;
  }
  async addBurnInputsIfNeeded() {
    if (this._initiator && this._totalBurns.size > 0 && this.notVisited("setTxInputs")) {
      const e = await this._initiator.getUsedUTxOs();
      os(this._totalBurns, e.map((s) => vt(s))).map((s) => M(s)).forEach((s) => {
        this._txInputsBuilder.add_input(s.output().address(), s.input(), s.output().amount());
      });
    }
  }
  async addChangeAddress() {
    if (this._initiator && this._changeAddress === void 0) {
      const e = await this._initiator.getUsedAddress();
      this._txBuilder.add_change_if_needed(e);
    } else
      this._changeAddress !== void 0 && this._txBuilder.add_change_if_needed(this._changeAddress);
  }
  async addCollateralIfNeeded() {
    if (this._initiator && this.notVisited("setCollateral")) {
      const e = await this._initiator.getUsedCollateral();
      this._txBuilder.set_collateral(xe(e));
    }
  }
  async addRequiredSignersIfNeeded() {
    if (this._initiator && this.notVisited("setRequiredSigners")) {
      const e = await this._initiator.getUsedAddress(), t = it(e.to_bech32());
      this._txBuilder.add_required_signer(H(t));
    }
  }
  async addTxInputsAsNeeded() {
    if (this.notVisited("setTxInputs")) {
      const e = await this.filterAvailableUTxOs();
      is(this._txOutputs, e.map((s) => vt(s))).map((s) => M(s)).forEach((s) => {
        this._txInputsBuilder.add_input(s.output().address(), s.input(), s.output().amount());
      });
    }
    if (this._txBuilder.set_inputs(this._txInputsBuilder), (this._mintBuilder.has_native_scripts() || this._mintBuilder.has_plutus_scripts()) && this._txBuilder.set_mint_builder(this._mintBuilder), this._txCertificates.len() > 0 && this._txBuilder.set_certs(this._txCertificates), this._txWithdrawals.len() > 0 && this._txBuilder.set_withdrawals(this._txWithdrawals), this._txBuilder.get_mint_builder() || this.notVisited("redeemValue") === !1) {
      const e = this._era !== void 0 ? Zt[this._era] : Zt.BABBAGE;
      this._txBuilder.calc_script_data_hash(e);
    }
  }
  async forgeAssetsIfNeeded() {
    const e = (t, s) => {
      const n = t.data.assetName, i = t.data.metadata, o = t.unit.slice(0, F);
      if (t.data.label === "777")
        return i;
      if (s && s[o]) {
        const { [o]: c, ...u } = s, d = {
          [n]: i,
          ...c
        };
        return {
          [o]: {
            ...d
          },
          ...u
        };
      }
      return s !== void 0 ? {
        [o]: {
          [n]: i
        },
        ...s
      } : {
        [o]: { [n]: i }
      };
    };
    await this.addBurnInputsIfNeeded(), Array.from(this._totalMints, (t) => ({
      unit: t[0],
      data: t[1]
    })).reduce((t, s) => t.set(s.data.label, e(s, t.get(s.data.label))), /* @__PURE__ */ new Map()).forEach((t, s) => {
      this._txBuilder.add_json_metadatum(a.BigNum.from_str(s), JSON.stringify(t));
    }), this.addMintOutputs();
  }
  async filterAvailableUTxOs(e = []) {
    return this._initiator === void 0 ? [] : (await this._initiator.getUsedUTxOs()).filter((s) => e.find((n) => n.input.txHash === s.input().transaction_id().to_hex()) === void 0);
  }
  addMintOutputs() {
    this._recipients.forEach((e, t) => {
      const n = Z(e).multiasset();
      if (n !== void 0) {
        const o = Ct(t).next().with_asset_and_min_required_coin_by_utxo_cost(n, Ht(this._protocolParameters.coinsPerUTxOSize)).build();
        this._txBuilder.add_output(o);
      }
    });
  }
  notVisited(e) {
    return this.__visits.includes(e) === !1;
  }
  setTxOutput(e) {
    const s = a.BigNum.from_str(this._txOutputs.get(e.unit) ?? "0").checked_add(a.BigNum.from_str(e.quantity)).to_str();
    this._txOutputs.set(e.unit, s);
  }
};
st([
  rt()
], $.prototype, "mintAsset", null);
st([
  rt()
], $.prototype, "redeemValue", null);
st([
  rt()
], $.prototype, "sendAssets", null);
st([
  rt()
], $.prototype, "sendValue", null);
st([
  rt()
], $.prototype, "setCollateral", null);
st([
  rt()
], $.prototype, "setRequiredSigners", null);
st([
  rt()
], $.prototype, "setTxInputs", null);
$ = st([
  Xs
], $);
class Zs {
  txHex = "";
  txBuilder = Et();
  txEvaluationMultiplier = 1.1;
  _protocolParams = v;
  txOutput;
  addingScriptInput = !1;
  addingPlutusMint = !1;
  isHydra = !1;
  meshTxBuilderBody;
  mintItem;
  txInQueueItem;
  collateralQueueItem;
  refScriptTxInQueueItem;
  reset = () => (this.txHex = "", this.txBuilder = Et(), this.txEvaluationMultiplier = 1.1, this._protocolParams = v, this.txOutput = void 0, this.addingScriptInput = !1, this.addingPlutusMint = !1, this.mintItem = void 0, this.txInQueueItem = void 0, this.collateralQueueItem = void 0, this.refScriptTxInQueueItem = void 0, this.meshTxBuilderBody = this.emptyTxBuilderBody(), this);
  emptyTxBuilderBody = () => ({
    inputs: [],
    outputs: [],
    collaterals: [],
    requiredSignatures: [],
    referenceInputs: [],
    mints: [],
    changeAddress: "",
    metadata: [],
    validityRange: {},
    signingKey: []
  });
  constructor() {
    this.meshTxBuilderBody = this.emptyTxBuilderBody();
  }
  completeSync = (e) => (e && (this.meshTxBuilderBody = e), this.serializeTxBody(this.meshTxBuilderBody));
  completeSigning = () => {
    const { signingKey: e } = this.meshTxBuilderBody;
    return e.length > 0 && this.addAllSigningKeys(e), this.txHex;
  };
  serializeTxBody = (e) => {
    const { inputs: t, outputs: s, collaterals: n, referenceInputs: i, mints: o, changeAddress: c, validityRange: u, requiredSignatures: d, metadata: A } = e;
    if (this.isHydra ? this.protocolParams({
      minFeeA: 0,
      minFeeB: 0,
      priceMem: 0,
      priceStep: 0,
      collateralPercent: 0,
      coinsPerUTxOSize: "0"
    }) : this.protocolParams({}), this.meshTxBuilderBody.mints.sort((l, g) => l.policyId.localeCompare(g.policyId)), this.meshTxBuilderBody.inputs.sort((l, g) => l.txIn.txHash === g.txIn.txHash ? l.txIn.txIndex - g.txIn.txIndex : l.txIn.txHash.localeCompare(g.txIn.txHash)), this.addAllInputs(t), this.addAllOutputs(s), this.addAllCollaterals(n), this.addAllReferenceInputs(i), this.addAllMints(o), this.addValidityRange(u), this.addAllRequiredSignatures(d), this.addAllMetadata(A), this.addCostModels(), c) {
      const l = this.meshTxBuilderBody.collaterals.map((g) => {
        var I, y;
        return ((y = (I = g.txIn.amount) == null ? void 0 : I.find((k) => k.unit === "lovelace")) == null ? void 0 : y.quantity) || "0";
      }).reduce((g, I) => g + parseInt(I), 0);
      l > 0 && (this.txBuilder.set_collateral_return(a.TransactionOutput.new(a.Address.from_bech32(c), a.Value.new(a.BigNum.from_str(String(l))))), this.txBuilder.set_total_collateral(a.BigNum.from_str(String(l)))), this.addChange(c), this.addCollateralReturn(c);
    }
    return this.buildTx(), this;
  };
  txIn = (e, t, s, n) => (this.txInQueueItem && this.queueInput(), this.addingScriptInput ? this.txInQueueItem = {
    type: "Script",
    txIn: {
      txHash: e,
      txIndex: t,
      amount: s,
      address: n
    },
    scriptTxIn: {}
  } : this.txInQueueItem = {
    type: "PubKey",
    txIn: {
      txHash: e,
      txIndex: t,
      amount: s,
      address: n
    }
  }, this.addingScriptInput = !1, this);
  txInScript = (e, t = "V2") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Datum value attempted to be called a non script input");
    return this.txInQueueItem.scriptTxIn.scriptSource = {
      type: "Provided",
      script: {
        code: e,
        version: t
      }
    }, this;
  };
  txInDatumValue = (e, t = "Mesh") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Datum value attempted to be called a non script input");
    if (t === "Mesh")
      return this.txInQueueItem.scriptTxIn.datumSource = {
        type: "Provided",
        data: {
          type: t,
          content: e
        }
      }, this;
    const s = this.castRawDataToJsonString(e);
    return this.txInQueueItem.scriptTxIn.datumSource = {
      type: "Provided",
      data: {
        type: t,
        content: s
      }
    }, this;
  };
  txInInlineDatumPresent = () => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Inline datum present attempted to be called a non script input");
    const { txHash: e, txIndex: t } = this.txInQueueItem.txIn;
    return e && t.toString() && (this.txInQueueItem.scriptTxIn.datumSource = {
      type: "Inline",
      txHash: e,
      txIndex: t
    }), this;
  };
  txInRedeemerValue = (e, t = { ...at }, s = "Mesh") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Spending tx in reference redeemer attempted to be called a non script input");
    if (s === "Mesh")
      return this.txInQueueItem.scriptTxIn.redeemer = {
        data: {
          type: s,
          content: e
        },
        exUnits: t
      }, this;
    const n = this.castRawDataToJsonString(e);
    return this.txInQueueItem.scriptTxIn.redeemer = {
      data: {
        type: s,
        content: n
      },
      exUnits: t
    }, this;
  };
  txOut = (e, t) => (this.txOutput && (this.meshTxBuilderBody.outputs.push(this.txOutput), this.txOutput = void 0), this.txOutput = {
    address: e,
    amount: t
  }, this);
  txOutDatumHashValue = (e, t = "Mesh") => {
    if (this.txOutput) {
      if (t === "Mesh")
        return this.txOutput.datum = {
          type: "Hash",
          data: {
            type: t,
            content: e
          }
        }, this;
      const s = this.castRawDataToJsonString(e);
      this.txOutput.datum = {
        type: "Hash",
        data: {
          type: t,
          content: s
        }
      };
    }
    return this;
  };
  txOutInlineDatumValue = (e, t = "Mesh") => {
    if (this.txOutput) {
      if (t === "Mesh")
        return this.txOutput.datum = {
          type: "Inline",
          data: {
            type: t,
            content: e
          }
        }, this;
      const s = this.castRawDataToJsonString(e);
      this.txOutput.datum = {
        type: "Inline",
        data: {
          type: t,
          content: s
        }
      };
    }
    return this;
  };
  txOutReferenceScript = (e, t = "V2") => (this.txOutput && (this.txOutput.referenceScript = { code: e, version: t }), this);
  spendingPlutusScriptV2 = () => (this.addingScriptInput = !0, this);
  spendingTxInReference = (e, t, s, n = "V2") => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Spending tx in reference attempted to be called a non script input");
    return this.txInQueueItem.scriptTxIn.scriptSource = {
      type: "Inline",
      txInInfo: {
        txHash: e,
        txIndex: t,
        spendingScriptHash: s,
        version: n
      }
    }, this;
  };
  spendingReferenceTxInInlineDatumPresent = () => (this.txInInlineDatumPresent(), this);
  spendingReferenceTxInRedeemerValue = (e, t = { ...at }) => (this.txInRedeemerValue(e, t), this);
  readOnlyTxInReference = (e, t) => (this.meshTxBuilderBody.referenceInputs.push({ txHash: e, txIndex: t }), this);
  mintPlutusScriptV2 = () => (this.addingPlutusMint = !0, this);
  mint = (e, t, s) => (this.mintItem && this.queueMint(), this.mintItem = {
    type: this.addingPlutusMint ? "Plutus" : "Native",
    policyId: t,
    assetName: s,
    amount: e
  }, this.addingPlutusMint = !1, this);
  mintingScript = (e, t = "V2") => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (!this.mintItem.type)
      throw Error("Mint information missing");
    return this.mintItem.scriptSource = {
      type: "Provided",
      script: { code: e, version: t }
    }, this;
  };
  mintTxInReference = (e, t, s = "V2") => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (!this.mintItem.type)
      throw Error("Mint information missing");
    if (this.mintItem.type == "Native")
      throw Error("Mint tx in reference can only be used on plutus script tokens");
    if (!this.mintItem.policyId)
      throw Error("PolicyId information missing from mint asset");
    return this.mintItem.scriptSource = {
      type: "Reference Script",
      txHash: e,
      txIndex: t,
      version: s
    }, this;
  };
  mintReferenceTxInRedeemerValue = (e, t = { ...at }, s = "Mesh") => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (this.mintItem.type == "Native")
      throw Error("Mint tx in reference can only be used on plutus script tokens");
    if (this.mintItem.type == "Plutus") {
      if (!this.mintItem.policyId)
        throw Error("PolicyId information missing from mint asset");
      if (s === "Mesh")
        return this.mintItem.redeemer = {
          data: {
            type: s,
            content: e
          },
          exUnits: t
        }, this;
      const n = this.castRawDataToJsonString(e);
      this.mintItem.redeemer = {
        data: {
          type: s,
          content: n
        },
        exUnits: t
      };
    }
    return this;
  };
  mintRedeemerValue = (e, t = { ...at }, s = "Mesh") => (this.mintReferenceTxInRedeemerValue(e, t, s), this);
  requiredSignerHash = (e) => (this.meshTxBuilderBody.requiredSignatures.push(e), this);
  txInCollateral = (e, t, s, n) => (this.collateralQueueItem && this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem), this.collateralQueueItem = {
    type: "PubKey",
    txIn: {
      txHash: e,
      txIndex: t,
      amount: s,
      address: n
    }
  }, this);
  changeAddress = (e) => (this.meshTxBuilderBody.changeAddress = e, this);
  invalidBefore = (e) => (this.meshTxBuilderBody.validityRange.invalidBefore = e, this);
  invalidHereafter = (e) => (this.meshTxBuilderBody.validityRange.invalidHereafter = e, this);
  metadataValue = (e, t) => (this.meshTxBuilderBody.metadata.push({ tag: e, metadata: t }), this);
  protocolParams = (e) => {
    const t = { ...v, ...e };
    return this._protocolParams = t, this.txBuilder = Et(t), this;
  };
  signingKey = (e) => (this.meshTxBuilderBody.signingKey.push(e), this);
  addAllSigningKeys = (e) => {
    if (e.length > 0) {
      const t = a.Vkeywitnesses.new(), s = a.Transaction.from_hex(this.txHex), n = s.body();
      e.forEach((c) => {
        const u = c.slice(0, 4) === "5820" ? c.slice(4) : c, d = a.PrivateKey.from_hex(u), A = a.make_vkey_witness(a.hash_transaction(n), d);
        t.add(A);
      });
      const i = s.witness_set();
      i.set_vkeys(t);
      const o = a.Transaction.new(n, i, s.auxiliary_data());
      this.txHex = o.to_hex();
    }
  };
  buildTx = () => {
    const e = this.txBuilder.build_tx();
    this.txHex = e.to_hex();
  };
  queueInput = () => {
    if (!this.txInQueueItem)
      throw Error("Undefined input");
    if (this.txInQueueItem.type === "Script")
      if (this.txInQueueItem.scriptTxIn) {
        if (!this.txInQueueItem.scriptTxIn.datumSource)
          throw Error("Script input does not contain datum information");
        if (!this.txInQueueItem.scriptTxIn.redeemer)
          throw Error("Script input does not contain redeemer information");
        if (!this.txInQueueItem.scriptTxIn.scriptSource)
          throw Error("Script input does not contain script information");
      } else
        throw Error("Script input does not contain script, datum, or redeemer information");
    this.meshTxBuilderBody.inputs.push(this.txInQueueItem), this.txInQueueItem = void 0;
  };
  queueMint = () => {
    if (!this.mintItem)
      throw Error("Undefined mint");
    if (!this.mintItem.scriptSource)
      throw Error("Missing mint script information");
    this.meshTxBuilderBody.mints.push(this.mintItem), this.mintItem = void 0;
  };
  makePlutusScriptSource = (e) => {
    const t = a.ScriptHash.from_hex(e.spendingScriptHash), s = a.TransactionInput.new(a.TransactionHash.from_hex(e.txHash), e.txIndex);
    return a.PlutusScriptSource.new_ref_input_with_lang_ver(t, s, R[e.version]);
  };
  addAllInputs = (e) => {
    for (let t = 0; t < e.length; t++) {
      const s = e[t];
      switch (s.type) {
        case "PubKey":
          this.addTxIn(s);
          break;
        case "Script":
          this.addScriptTxIn(s);
          break;
      }
    }
  };
  addTxIn = (e) => {
    this.txBuilder.add_input(a.Address.from_bech32(e.txIn.address), a.TransactionInput.new(a.TransactionHash.from_hex(e.txIn.txHash), e.txIn.txIndex), Z(e.txIn.amount));
  };
  addScriptTxIn = ({ scriptTxIn: e, txIn: t }) => {
    let s;
    const { datumSource: n, scriptSource: i, redeemer: o } = e;
    if (n.type === "Provided")
      s = a.DatumSource.new(this.castDataToPlutusData(n.data));
    else {
      const d = a.TransactionInput.new(a.TransactionHash.from_hex(n.txHash), n.txIndex);
      s = a.DatumSource.new_ref_input(d);
    }
    let c;
    i.type == "Inline" ? c = this.makePlutusScriptSource(i.txInInfo) : c = a.PlutusScriptSource.new(a.PlutusScript.from_hex_with_version(i.script.code, R[i.script.version]));
    const u = a.Redeemer.new(a.RedeemerTag.new_spend(), a.BigNum.from_str("0"), this.castDataToPlutusData(o.data), a.ExUnits.new(a.BigNum.from_str(String(o.exUnits.mem)), a.BigNum.from_str(String(o.exUnits.steps))));
    this.txBuilder.add_plutus_script_input(a.PlutusWitness.new_with_ref(c, s, u), a.TransactionInput.new(a.TransactionHash.from_hex(t.txHash), t.txIndex), Z(t.amount));
  };
  addAllOutputs = (e) => {
    for (let t = 0; t < e.length; t++) {
      const s = e[t];
      this.addOutput(s);
    }
  };
  addOutput = ({ amount: e, address: t, datum: s, referenceScript: n }) => {
    const i = Z(e), o = i.multiasset();
    if (i.is_zero() && o === void 0)
      throw Error("Invalid output amount");
    let c = a.TransactionOutputBuilder.new().with_address(K(t));
    s && s.type === "Hash" && (c = c.with_data_hash(a.hash_plutus_data(this.castDataToPlutusData(s.data)))), s && s.type === "Inline" && (c = c.with_plutus_data(this.castDataToPlutusData(s.data))), n && (c = c.with_script_ref(a.ScriptRef.new_plutus_script(a.PlutusScript.from_hex_with_version(n.code, R[n.version]))));
    const u = c.next();
    if (o) {
      const d = i.coin().is_zero() ? u.with_asset_and_min_required_coin_by_utxo_cost(o, Ht(this._protocolParams.coinsPerUTxOSize)).build() : u.with_coin_and_asset(i.coin(), o).build();
      this.txBuilder.add_output(d);
    } else {
      const d = u.with_coin(i.coin()).build();
      this.txBuilder.add_output(d);
    }
  };
  addAllCollaterals = (e) => {
    const t = a.TxInputsBuilder.new();
    for (let s = 0; s < e.length; s++) {
      const n = e[s];
      this.addCollateral(t, n);
    }
    this.txBuilder.set_collateral(t);
  };
  addCollateral = (e, t) => {
    e.add_input(a.Address.from_bech32(t.txIn.address), a.TransactionInput.new(a.TransactionHash.from_hex(t.txIn.txHash), t.txIn.txIndex), Z(t.txIn.amount));
  };
  addCollateralReturn = (e) => {
    var s;
    const t = (s = this.txBuilder.get_fee_if_set()) == null ? void 0 : s.to_js_value();
    if (t) {
      const n = Math.ceil(this._protocolParams.collateralPercent * Number(t) / 100);
      this.txBuilder.set_total_collateral_and_return(a.BigNum.from_str(String(n)), a.Address.from_bech32(e));
    }
  };
  addAllReferenceInputs = (e) => {
    e.forEach((t) => {
      this.addReferenceInput(t);
    });
  };
  addReferenceInput = ({ txHash: e, txIndex: t }) => {
    const s = a.TransactionInput.new(a.TransactionHash.from_hex(e), t);
    this.txBuilder.add_reference_input(s);
  };
  addAllMints = (e) => {
    const t = a.MintBuilder.new();
    let s = 0;
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (!i.scriptSource)
        throw Error("Mint script is expected to be provided");
      if (i.type === "Plutus") {
        if (!i.redeemer)
          throw Error("Missing mint redeemer information");
        this.addPlutusMint(t, i, s), s++;
      } else
        i.type === "Native" && this.addNativeMint(t, i);
    }
    this.txBuilder.set_mint_builder(t);
  };
  addPlutusMint = (e, { redeemer: t, policyId: s, scriptSource: n, assetName: i, amount: o }, c) => {
    const u = a.Redeemer.new(a.RedeemerTag.new_mint(), a.BigNum.from_str(String(c)), this.castDataToPlutusData(t.data), a.ExUnits.new(a.BigNum.from_str(String(t.exUnits.mem)), a.BigNum.from_str(String(t.exUnits.steps)))), d = n.type === "Reference Script" ? a.PlutusScriptSource.new_ref_input_with_lang_ver(a.ScriptHash.from_hex(s), a.TransactionInput.new(a.TransactionHash.from_hex(n.txHash), n.txIndex), R[n.version]) : a.PlutusScriptSource.new(a.PlutusScript.from_hex_with_version(n.script.code, R[n.script.version]));
    e.add_asset(a.MintWitness.new_plutus_script(d, u), a.AssetName.new(Buffer.from(i, "hex")), a.Int.new_i32(o));
  };
  addNativeMint = (e, { scriptSource: t, assetName: s, amount: n }) => {
    if (t.type === "Reference Script")
      throw Error("Native mint cannot have reference script");
    e.add_asset(a.MintWitness.new_native_script(a.NativeScript.from_hex(t.script.code)), a.AssetName.new(Buffer.from(s, "hex")), a.Int.new_i32(n));
  };
  queueAllLastItem = () => {
    this.txOutput && (this.meshTxBuilderBody.outputs.push(this.txOutput), this.txOutput = void 0), this.txInQueueItem && this.queueInput(), this.collateralQueueItem && this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem), this.mintItem && this.queueMint();
  };
  addCostModels = () => {
    this.txBuilder.calc_script_data_hash(a.TxBuilderConstants.plutus_vasil_cost_models());
  };
  addChange = (e) => {
    this.txBuilder.add_change_if_needed(a.Address.from_bech32(e));
  };
  addValidityRange = ({ invalidBefore: e, invalidHereafter: t }) => {
    e && this.txBuilder.set_validity_start_interval_bignum(a.BigNum.from_str(e.toString())), t && this.txBuilder.set_ttl_bignum(a.BigNum.from_str(t.toString()));
  };
  addAllRequiredSignatures = (e) => {
    e.forEach((t) => {
      this.txBuilder.add_required_signer(a.Ed25519KeyHash.from_hex(t));
    });
  };
  addAllMetadata = (e) => {
    e.forEach(({ tag: t, metadata: s }) => {
      this.txBuilder.add_json_metadatum(a.BigNum.from_str(t), JSON.stringify(s));
    });
  };
  updateRedeemer = (e, t) => {
    t.forEach((s) => {
      switch (s.tag) {
        case "SPEND": {
          const n = e.inputs[s.index];
          n.type == "Script" && n.scriptTxIn.redeemer && (n.scriptTxIn.redeemer.exUnits.mem = Math.floor(s.budget.mem * this.txEvaluationMultiplier), n.scriptTxIn.redeemer.exUnits.steps = Math.floor(s.budget.steps * this.txEvaluationMultiplier));
          break;
        }
        case "MINT": {
          const n = e.mints[s.index];
          n.type == "Plutus" && n.redeemer && (n.redeemer.exUnits.mem = Math.floor(s.budget.mem * this.txEvaluationMultiplier), n.redeemer.exUnits.steps = Math.floor(s.budget.steps * this.txEvaluationMultiplier));
          break;
        }
      }
    });
  };
  castRawDataToJsonString = (e) => typeof e == "object" ? JSON.stringify(e) : e;
  castDataToPlutusData = ({ type: e, content: t }) => e === "Mesh" ? tt(t) : a.PlutusData.from_json(t, a.PlutusDatumSchema.DetailedSchema);
}
class Dr extends Zs {
  _fetcher;
  _submitter;
  _evaluator;
  queriedTxHashes = /* @__PURE__ */ new Set();
  queriedUTxOs = {};
  constructor({ fetcher: e, submitter: t, evaluator: s, isHydra: n = !1 }) {
    super(), e && (this._fetcher = e), t && (this._submitter = t), s && (this._evaluator = s), n && (this.isHydra = !0);
  }
  complete = async (e) => {
    e ? this.meshTxBuilderBody = e : this.queueAllLastItem(), await this.queryAllTxInfo();
    const { inputs: t, collaterals: s } = this.meshTxBuilderBody;
    if ([...t, ...s].forEach((n) => {
      this.completeTxInformation(n);
    }), this.completeSync(e), this._evaluator) {
      const n = await this._evaluator.evaluateTx(this.txHex);
      this.updateRedeemer(this.meshTxBuilderBody, n), this.completeSync(e);
    }
    return this;
  };
  submitTx = async (e) => {
    var s;
    return await ((s = this._submitter) == null ? void 0 : s.submitTx(e));
  };
  getUTxOInfo = async (e) => {
    var s;
    let t = [];
    this.queriedTxHashes.has(e) || (this.queriedTxHashes.add(e), t = await ((s = this._fetcher) == null ? void 0 : s.fetchUTxOs(e)) || [], this.queriedUTxOs[e] = t);
  };
  queryAllTxInfo = () => {
    var n, i;
    const e = [], { inputs: t, collaterals: s } = this.meshTxBuilderBody;
    if (t.length + s.length > 0 && !this._fetcher)
      throw Error("Transaction information is incomplete while no fetcher instance is provided");
    for (let o = 0; o < t.length; o++) {
      const c = t[o];
      if ((!c.txIn.amount || !c.txIn.address) && e.push(this.getUTxOInfo(c.txIn.txHash)), c.type === "Script" && ((n = c.scriptTxIn.scriptSource) == null ? void 0 : n.type) == "Inline" && c.scriptTxIn.scriptSource.txInInfo && !((i = c.scriptTxIn.scriptSource) != null && i.txInInfo.spendingScriptHash)) {
        const u = c.scriptTxIn.scriptSource.txInInfo.txHash;
        e.push(this.getUTxOInfo(u));
      }
    }
    for (let o = 0; o < s.length; o++) {
      const c = s[o];
      (!c.txIn.amount || !c.txIn.address) && e.push(this.getUTxOInfo(c.txIn.txHash));
    }
    return Promise.all(e);
  };
  completeTxInformation = (e) => {
    var o;
    const s = this.queriedUTxOs[e.txIn.txHash].find((c) => c.input.outputIndex === e.txIn.txIndex), n = s == null ? void 0 : s.output.address, i = s == null ? void 0 : s.output.amount;
    if (!n || n === "" || !i || i.length === 0)
      throw Error(`Couldn't find information for ${e.txIn.txHash}#${e.txIn.txIndex}`);
    if (e.txIn.address = n, e.txIn.amount = i, e.type === "Script" && ((o = e.scriptTxIn.scriptSource) == null ? void 0 : o.type) == "Inline") {
      const c = e.scriptTxIn.scriptSource.txInInfo;
      if (!c.spendingScriptHash) {
        const d = this.queriedUTxOs[c.txHash].find((A) => A.input.outputIndex === c.txIndex);
        if (!d)
          throw Error(`Couldn't find script reference utxo for ${c.txHash}#${c.txIndex}`);
        c.spendingScriptHash = d == null ? void 0 : d.output.scriptHash;
      }
    }
  };
}
class C {
  _networkId;
  _encryptedSecret;
  constructor(e, t) {
    this._networkId = e, this._encryptedSecret = t;
  }
  getAccount(e, t) {
    return this.accountContext(e, t, (s, n) => {
      const i = fe(this._networkId, s.to_public().hash(), n.to_public().hash()).to_address().to_bech32(), o = _e(this._networkId, s.to_public().hash()).to_address().to_bech32(), c = Ft(this._networkId, n.to_public().hash()).to_address().to_bech32();
      return {
        baseAddress: i,
        enterpriseAddress: o,
        rewardAddress: c
      };
    });
  }
  signData(e, t, s, n) {
    try {
      return this.accountContext(e, t, (i, o) => {
        const c = { payload: n }, u = {
          address: C.resolveAddress(this._networkId, s, i, o),
          key: s.startsWith("stake") ? o : i
        }, { coseSign1: d, coseKey: A } = As(c, u);
        return { signature: d, key: A };
      });
    } catch (i) {
      throw new Error(`An error occurred during signData: ${i}.`);
    }
  }
  signTx(e, t, s, n, i) {
    try {
      const o = Me(js(n));
      return this.accountContext(e, t, (c, u) => {
        const d = a.Vkeywitnesses.new();
        return C.resolveSigners(n, s, c.to_public().hash().to_hex()).forEach((l) => {
          if (l === c.to_public().hash().to_hex())
            d.add(a.make_vkey_witness(o, c));
          else if (l === u.to_public().hash().to_hex())
            d.add(a.make_vkey_witness(o, u));
          else if (i === !1)
            throw new Error(`Missing key witness for: ${l}`);
        }), d;
      });
    } catch (o) {
      throw new Error(`An error occurred during signTx: ${o}.`);
    }
  }
  static encryptMnemonic(e, t) {
    const s = we(e.join(" ")), n = qe(s), i = b(n.as_bytes());
    return n.free(), C.encrypt(i, t);
  }
  static encryptPrivateKey(e, t) {
    const s = a.Bip32PrivateKey.from_bech32(e), n = b(s.as_bytes());
    return s.free(), C.encrypt(n, t);
  }
  static encryptSigningKeys(e, t, s) {
    const n = C.encrypt(e.slice(4), s), i = C.encrypt(t.slice(4), s);
    return [n, i];
  }
  static generateMnemonic(e = 256) {
    return ze(e).split(" ");
  }
  accountContext(e, t, s) {
    const { paymentKey: n, stakeKey: i } = C.resolveKeys(e, t, this._encryptedSecret), o = s(n, i);
    return n.free(), i.free(), o;
  }
  static decrypt(e, t) {
    try {
      return a.decrypt_with_password(E(t), e);
    } catch {
      throw new Error("The password is incorrect.");
    }
  }
  static encrypt(e, t) {
    const s = Ce("0123456789abcdef"), n = s(64), i = s(24);
    return a.encrypt_with_password(E(t), n, i, e);
  }
  static resolveAddress(e, t, s, n) {
    const i = [
      fe(e, s.to_public().hash(), n.to_public().hash()),
      _e(e, s.to_public().hash()),
      Ft(e, n.to_public().hash())
    ].find((o) => o.to_address().to_bech32() === t);
    if (i !== void 0)
      return i.to_address();
    throw new Error(`Address: ${t} doesn't belong to this account.`);
  }
  static resolveKeys(e, t, s) {
    if (typeof s == "string") {
      const o = C.decrypt(s, t);
      return Hs(o, e);
    }
    const n = C.decrypt(s[0], t), i = C.decrypt(s[1], t);
    return {
      paymentKey: a.PrivateKey.from_hex(n),
      stakeKey: a.PrivateKey.from_hex(i)
    };
  }
  static resolveSigners(e, t, s) {
    const n = (c) => {
      const u = (f, S = [], w = 0) => {
        var ft, lt, $t, zt, Wt;
        if (f === void 0 || w >= f.len())
          return S;
        const T = f.get(w), U = new Array();
        switch (T.kind()) {
          case a.CertificateKind.StakeDeregistration: {
            const x = (ft = T.as_stake_deregistration()) == null ? void 0 : ft.stake_credential(), V = (x == null ? void 0 : x.kind()) === a.StakeCredKind.Key ? x.to_keyhash() : void 0;
            V && U.push(V.to_hex());
            break;
          }
          case a.CertificateKind.StakeDelegation: {
            const x = (lt = T.as_stake_delegation()) == null ? void 0 : lt.stake_credential(), V = (x == null ? void 0 : x.kind()) === a.StakeCredKind.Key ? x.to_keyhash() : void 0;
            V && U.push(V.to_hex());
            break;
          }
          case a.CertificateKind.PoolRegistration: {
            const x = ($t = T.as_pool_registration()) == null ? void 0 : $t.pool_params().pool_owners();
            U.push(...A(x));
            break;
          }
          case a.CertificateKind.PoolRetirement: {
            const x = (zt = T.as_pool_retirement()) == null ? void 0 : zt.pool_keyhash();
            x && U.push(x.to_hex());
            break;
          }
          case a.CertificateKind.MoveInstantaneousRewardsCert: {
            const x = (Wt = T.as_move_instantaneous_rewards_cert()) == null ? void 0 : Wt.move_instantaneous_reward().as_to_stake_creds();
            if (x)
              for (let V = 0; V < x.len(); V += 1) {
                const Jt = x.keys().get(V), jt = Jt.kind() === a.StakeCredKind.Key ? Jt.to_keyhash() : void 0;
                jt && U.push(jt.to_hex());
              }
            break;
          }
        }
        return u(f, [...S, ...U], w + 1);
      }, d = (f, S = [], w = 0) => {
        if (f === void 0 || w >= f.len())
          return S;
        const T = f.get(w).index(), U = f.get(w).transaction_id(), ft = t.find((lt) => lt.input.outputIndex === T && lt.input.txHash === U.to_hex()) !== void 0 ? s : "OUR_PRINCESS_IS_IN_ANOTHER_CASTLE";
        return d(f, [...S, ft], w + 1);
      }, A = (f, S = [], w = 0) => f === void 0 || w >= f.len() ? S : A(f, [...S, f.get(w).to_hex()], w + 1), l = (f, S = [], w = 0) => {
        if (f === void 0 || w >= f.len())
          return S;
        const T = f.keys().get(w).payment_cred(), U = T.kind() === a.StakeCredKind.Key ? T.to_keyhash() : void 0;
        return l(f, U ? [...S, U.to_hex()] : S, w + 1);
      }, g = c.certs(), I = c.collateral(), y = c.inputs(), k = c.required_signers(), z = c.withdrawals();
      return [
        ...u(g),
        ...d(I),
        ...d(y),
        ...A(k),
        ...l(z)
      ];
    }, i = (c) => {
      const u = (A, l = []) => {
        var g, I, y, k;
        if (A)
          for (let z = 0; z < A.len(); z += 1) {
            const f = A.get(z);
            switch (f.kind()) {
              case a.NativeScriptKind.ScriptPubkey: {
                const S = (g = f.as_script_pubkey()) == null ? void 0 : g.addr_keyhash().to_hex();
                return S ? [...l, S] : l;
              }
              case a.NativeScriptKind.ScriptAll:
                return u((I = f.as_script_all()) == null ? void 0 : I.native_scripts(), l);
              case a.NativeScriptKind.ScriptAny:
                return u((y = f.as_script_any()) == null ? void 0 : y.native_scripts(), l);
              case a.NativeScriptKind.ScriptNOfK:
                return u((k = f.as_script_n_of_k()) == null ? void 0 : k.native_scripts(), l);
            }
          }
        return l;
      }, d = c.native_scripts();
      return [
        ...u(d)
      ];
    }, o = Y(e);
    return /* @__PURE__ */ new Set([
      ...n(o.body()),
      ...i(o.witness_set())
    ]);
  }
}
const P = "MARI0TIME";
class kr {
  _fetcher;
  _submitter;
  _wallet;
  constructor(e) {
    switch (this._fetcher = e.fetcher, this._submitter = e.submitter, e.key.type) {
      case "mnemonic":
        this._wallet = new C(e.networkId, C.encryptMnemonic(e.key.words, P));
        break;
      case "root":
        this._wallet = new C(e.networkId, C.encryptPrivateKey(e.key.bech32, P));
        break;
      case "cli":
        this._wallet = new C(e.networkId, C.encryptSigningKeys(e.key.payment, e.key.stake ?? "f0".repeat(34), P));
    }
  }
  getBaseAddress(e = 0) {
    return this._wallet.getAccount(e, P).baseAddress;
  }
  getPaymentAddress(e = 0) {
    return this._wallet.getAccount(e, P).enterpriseAddress;
  }
  getRewardAddress(e = 0) {
    return this._wallet.getAccount(e, P).rewardAddress;
  }
  getUsedAddress(e = 0) {
    const t = this._wallet.getAccount(e, P);
    return K(t.enterpriseAddress);
  }
  getUsedCollateral(e = v.maxCollateralInputs) {
    throw new Error("getUsedCollateral not implemented.");
  }
  async getUsedUTxOs(e = 0) {
    const t = this._wallet.getAccount(e, P);
    return (await this._fetcher.fetchAddressUTxOs(t.enterpriseAddress)).map((n) => M(n));
  }
  signData(e, t, s = 0) {
    try {
      return this._wallet.signData(s, P, e, t);
    } catch (n) {
      throw new Error(`[AppWallet] An error occurred during signData: ${n}.`);
    }
  }
  async signTx(e, t = !1, s = 0) {
    try {
      const n = this._wallet.getAccount(s, P), i = await this._fetcher.fetchAddressUTxOs(n.enterpriseAddress), o = this._wallet.signTx(s, P, i, e, t), c = Y(e), u = c.witness_set(), d = Ge(u, o);
      return u.set_vkeys(d), a.Transaction.new(c.body(), u, c.auxiliary_data()).to_hex();
    } catch (n) {
      throw new Error(`[AppWallet] An error occurred during signTx: ${n}.`);
    }
  }
  submitTx(e) {
    return this._submitter.submitTx(e);
  }
  static brew(e = 256) {
    return C.generateMnemonic(e);
  }
}
class Ot {
  _walletInstance;
  constructor(e) {
    this._walletInstance = e;
  }
  static getInstalledWallets() {
    return window.cardano === void 0 ? [] : te.filter((e) => window.cardano[e] !== void 0).map((e) => ({
      name: window.cardano[e].name,
      icon: window.cardano[e].icon,
      version: window.cardano[e].apiVersion
    }));
  }
  static async enable(e) {
    try {
      const t = await Ot.resolveInstance(e);
      if (t !== void 0)
        return new Ot(t);
      throw new Error(`Couldn't create an instance of wallet: ${e}`);
    } catch (t) {
      throw new Error(`[BrowserWallet] An error occurred during enable: ${t}.`);
    }
  }
  async getBalance() {
    const e = await this._walletInstance.getBalance();
    return Re(Gs(e));
  }
  async getChangeAddress() {
    const e = await this._walletInstance.getChangeAddress();
    return nt(e).to_bech32();
  }
  async getCollateral(e = v.maxCollateralInputs) {
    return (await this.getUsedCollateral(e)).map((s) => vt(s));
  }
  getNetworkId() {
    return this._walletInstance.getNetworkId();
  }
  async getRewardAddresses() {
    return (await this._walletInstance.getRewardAddresses()).map((t) => nt(t).to_bech32());
  }
  async getUnusedAddresses() {
    return (await this._walletInstance.getUnusedAddresses()).map((t) => nt(t).to_bech32());
  }
  async getUsedAddresses() {
    return (await this._walletInstance.getUsedAddresses()).map((t) => nt(t).to_bech32());
  }
  async getUtxos() {
    return (await this.getUsedUTxOs()).map((t) => vt(t));
  }
  signData(e, t) {
    const s = K(e).to_hex();
    return this._walletInstance.signData(s, E(t));
  }
  async signTx(e, t = !1) {
    try {
      const s = Y(e), n = s.witness_set(), i = await this._walletInstance.signTx(e, t), o = Ls(i).vkeys() ?? a.Vkeywitnesses.new(), c = Ge(n, o);
      return n.set_vkeys(c), b(a.Transaction.new(s.body(), n, s.auxiliary_data()).to_bytes());
    } catch (s) {
      throw new Error(`[BrowserWallet] An error occurred during signTx: ${JSON.stringify(s)}.`);
    }
  }
  submitTx(e) {
    return this._walletInstance.submitTx(e);
  }
  async getUsedAddress() {
    const e = await this._walletInstance.getUsedAddresses();
    return nt(e[0]);
  }
  async getUsedCollateral(e = v.maxCollateralInputs) {
    return (await this._walletInstance.experimental.getCollateral() ?? []).map((s) => Ie(s)).slice(0, e);
  }
  async getUsedUTxOs() {
    return (await this._walletInstance.getUtxos() ?? []).map((t) => Ie(t));
  }
  async getAssets() {
    return (await this.getBalance()).filter((t) => t.unit !== "lovelace").map((t) => {
      const s = t.unit.slice(0, F), n = t.unit.slice(F), i = Js(s, n);
      return {
        unit: t.unit,
        policyId: s,
        assetName: Gt(n),
        fingerprint: i,
        quantity: t.quantity
      };
    });
  }
  async getLovelace() {
    const t = (await this.getBalance()).find((s) => s.unit === "lovelace");
    return t !== void 0 ? t.quantity : "0";
  }
  async getPolicyIdAssets(e) {
    return (await this.getAssets()).filter((s) => s.policyId === e);
  }
  async getPolicyIds() {
    const e = await this.getBalance();
    return Array.from(new Set(e.map((t) => t.unit.slice(0, F)))).filter((t) => t !== "lovelace");
  }
  static resolveInstance(e) {
    if (window.cardano === void 0)
      return;
    const t = te.map((s) => window.cardano[s]).filter((s) => s !== void 0).find((s) => s.name.toLowerCase() === e.toLowerCase());
    return t == null ? void 0 : t.enable();
  }
}
const $e = "http://localhost:4000/", tr = "http://localhost:5000/", er = `${$e}access`, sr = `${$e}transaction/signtx`;
class Tr {
  static getAxiosInstance() {
    return L.create({
      baseURL: tr,
      withCredentials: !0
    });
  }
  static getAppId() {
    return window.location.hostname;
  }
  static async openMinaFrontend(e) {
    const t = this.getAppId();
    e.includes("?") ? e = `${e}&appId=${t}` : e = `${e}?appId=${t}`;
    const s = "left=100,top=100,width=540,height=540", n = window.open(e, "meshWindow", s);
    return n || console.error("the window did not open", n), await (async () => new Promise((i) => {
      window.addEventListener("message", async (o) => {
        o.data.target == "minaWallet" && i(o.data);
      });
    }))();
  }
  static async get(e, t = {}) {
    const s = this.getAppId();
    t = {
      ...t,
      appId: s
    };
    try {
      return (await this.getAxiosInstance().get(e, {
        params: t
      })).data;
    } catch {
      console.error("Not logged in");
      return;
    }
  }
  static async enable() {
    return await this.get("wallet/getuserwalletsmeta") === void 0 ? await this.openMinaFrontend(er) : !0;
  }
  static async getChangeAddress(e = void 0, t = void 0) {
    return await this.get("wallet/getchangeaddress", {
      walletId: e,
      accountIndex: t
    });
  }
  static async getUtxos(e = void 0, t = void 0) {
    return await this.get("wallet/getutxo", {
      walletId: e,
      accountIndex: t
    });
  }
  static async signTx(e, t = !1) {
    const s = await this.get("wallet/getuserwalletsmeta");
    if (console.log("userWalletsMeta", s), s) {
      const n = await this.openMinaFrontend(`${sr}?unsignedTx=${e}&partialSign=${t}`);
      if (n instanceof a.Vkeywitnesses) {
        const i = Y(e), o = i.witness_set();
        o.set_vkeys(n);
        const c = a.Transaction.new(i.body(), o, i.auxiliary_data()).to_hex();
        return console.log("signedTx", c), c;
      }
    } else
      return;
  }
}
export {
  kr as AppWallet,
  Cr as BlockfrostProvider,
  Ot as BrowserWallet,
  C as EmbeddedWallet,
  br as ForgeScript,
  wr as InfuraProvider,
  Br as KoiosProvider,
  Qr as MaestroProvider,
  Dr as MeshTxBuilder,
  Tr as MinaWallet,
  Sr as OgmiosProvider,
  Er as TangoProvider,
  $ as Transaction,
  cr as checkSignature,
  _r as generateNonce,
  es as isNetwork,
  is as keepRelevant,
  or as largestFirst,
  os as largestFirstMultiAsset,
  et as parseAssetUnit,
  h as parseHttpError,
  yr as readPlutusData,
  xr as readTransaction,
  ur as resolveDataHash,
  dr as resolveEpochNo,
  Js as resolveFingerprint,
  hr as resolveLanguageView,
  lr as resolveNativeScriptHash,
  it as resolvePaymentKeyHash,
  Ar as resolvePlutusScriptAddress,
  gr as resolvePlutusScriptHash,
  mr as resolvePoolId,
  Ir as resolvePrivateKey,
  Ut as resolveRewardAddress,
  pr as resolveScriptRef,
  fr as resolveSlotNo,
  gt as resolveStakeKeyHash,
  Le as resolveTxFees,
  js as resolveTxHash
};
